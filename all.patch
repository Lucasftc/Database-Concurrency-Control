diff --git a/.vscode/settings.json b/.vscode/settings.json
index bc52b73..5f5cf67 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -5,6 +5,7 @@
         "istream": "cpp",
         "ostream": "cpp",
         "sstream": "cpp",
-        "tuple": "cpp"
+        "tuple": "cpp",
+        "system_error": "cpp"
     }
 }
\ No newline at end of file
diff --git a/README.md b/README.md
index 112c79c..7b9b50e 100644
--- a/README.md
+++ b/README.md
@@ -31,3 +31,44 @@ DBMS configurations can be changed in the config.h file. Please refer to README
                         (TEMPLATE, CALVIN) (You need to implement MVCC, , TO, etc.) 
     MAX_TXN_IN_FLIGHT : Maximum number of active transactions at each server at a given time
     DONE_TIMER        : Amount of time to run experiment
+
+DA 
+---
+The DBMS can use DA workload. This workload will executes a given sequence of transaction operations and prints out the actual execution results.
+
+To use this workload, you can only use a single node, a single worker thread, and a single messaging thread.
+Here are some of the configurations that need to be modified in the `config.h` file
+
+    #define NODE_CNT 1
+    #define THREAD_CNT 1
+    #define REM_THREAD_CNT 1
+    #define SEND_THREAD_CNT 1
+
+    #define CLIENT_NODE_CNT 1
+    #define CLIENT_THREAD_CNT 1
+    #define CLIENT_REM_THREAD_CNT 1
+    #define CLIENT_SEND_THREAD_CNT 1
+
+    #define WORKLOAD DA
+
+In addition, the client and server need to be placed only on one machine!
+Only two lines of the same IP address can be written in the `ifconfig.txt` file, and this IP address is the machine you want to test.
+Here is an example of this file:
+
+    10.77.110.148
+    10.77.110.148
+
+After modifying all the above parameters, the next step is to determine the sequence of transaction operations to be performed. This sequence needs to be written in the `input.txt` file. Examples are as follows:
+
+    W0a R1b W1a R1c C1 W0b C0
+    R2a R3b W2b W3a C2 C3
+
+A row represents a sequence.
+
+Now to test, you need to perform the following command on the machine which you want to test in:
+
+    ./rundb -nid0
+    ./runcl -nid1
+
+Finally, check the results, which are output in the `commit_histroy.txt` file.
+Compare whether the actual execution results in the file meet the logic of your concurrency control algorithm. If so, it is proved that the algorithm is implemented correctly.
\ No newline at end of file
diff --git a/abort_histroy.txt b/abort_histroy.txt
new file mode 100644
index 0000000..e69de29
diff --git a/benchmarks/creator.cpp b/benchmarks/creator.cpp
new file mode 100644
index 0000000..e395773
--- /dev/null
+++ b/benchmarks/creator.cpp
@@ -0,0 +1,195 @@
+
+#include <random>
+
+#include "creator.h"
+
+
+  InputActionSequenceCreator::InputActionSequenceCreator(const std::string &path) : path_(path) {}
+  InputActionSequenceCreator::~InputActionSequenceCreator() {}
+  void InputActionSequenceCreator::DeliverActionSequences(
+      const std::function<void(ActionSequence &&,uint64_t)> &handle) const {
+    std::ifstream fs(path_);
+    if (!fs) {
+      std::cerr << "Open Action Sequences File Failed" << std::endl;
+      return;
+    }
+    uint64_t seq_id=0;
+    ActionSequence act_seq;
+    while (fs >> act_seq) {
+      handle(std::move(act_seq),seq_id);
+    }
+  }
+
+
+
+
+uint64_t TraversalActionSequenceCreator::cut_down_ = 0;
+//uint64_t TraversalActionSequenceCreator::seq_id_ = 0;
+
+  TraversalActionSequenceCreator::TraversalActionSequenceCreator(const Options &opt)
+      : trans_num_(opt.trans_num),
+        item_num_(opt.item_num),
+        dml_act_num_(opt.max_dml),
+        subtask_num_(opt.subtask_num),
+        dfs_cnt_(opt.subtask_num - opt.subtask_id),
+        with_abort_(opt.with_abort),
+        tail_dtl_(opt.tail_dtl),
+        save_history_with_empty_opt_(opt.save_history_with_empty_opt),
+        dynamic_seq_len_(opt.dynamic_seq_len),
+        seq_id_(0) {}
+
+  void TraversalActionSequenceCreator::DeliverActionSequences(const std::function<void(ActionSequence &&,uint64_t)> &handle) const {
+    std::vector<Action> tmp_actions;
+    RecursiveFillDMLActionSeq(
+        [this, &handle](const ActionSequence &dml_act_seq,uint64_t seq_id, const uint64_t max_trans_id) {
+          HandleDMLActionSeq(handle, seq_id, dml_act_seq, max_trans_id);
+        },
+        tmp_actions, 0, 0);
+  }
+
+
+  void TraversalActionSequenceCreator::HandleActionSeq(const std::function<void(ActionSequence &&,uint64_t)> &handle,uint64_t seq_id,
+                       const ActionSequence &act_seq) const {
+    ActionSequence act_seq_copy = act_seq;  // copy ActionSequence
+    handle(std::move(act_seq_copy),seq_id);
+  }
+  void TraversalActionSequenceCreator::HandleDTLActionSeq(const std::function<void(ActionSequence &&,uint64_t)> &handle,uint64_t seq_id,
+                          const ActionSequence &dml_act_seq,
+                          const ActionSequence &dtl_act_seq) const {
+    // Firstly, append every dml_act_seq with dtl_act_seq.
+    ActionSequence act_seq_tot = dml_act_seq + dtl_act_seq;
+    // Then move dtl_act_seq at a suitable location, forward.
+    RecursiveMoveForwardDTLAction(
+        [this, &handle,seq_id](const ActionSequence &act_seq) { HandleActionSeq(handle, seq_id ,act_seq); },
+        act_seq_tot, dml_act_seq.size());
+  }
+  void TraversalActionSequenceCreator::HandleDMLActionSeq(const std::function<void(ActionSequence &&,uint64_t)> &handle,uint64_t seq_id,
+                          const ActionSequence &dml_act_seq, const uint64_t max_trans_id) const {
+    std::vector<Action::Type> dtl_act_types;
+    RecursiveFillDTLActionSeq(
+        [this, &handle, &dml_act_seq,seq_id](const ActionSequence &dtl_act_seq) {
+          HandleDTLActionSeq(handle, seq_id,dml_act_seq, dtl_act_seq);
+        },
+        dtl_act_types, max_trans_id, 0);
+  }
+
+  bool TraversalActionSequenceCreator::SkipDMLAction(const std::vector<Action> &actions) const {
+    assert(!actions.empty());
+    if (actions.size() == 1) {
+      return false;
+    }
+    const Action &last_action = actions[actions.size() - 2];
+    const Action &cur_action = actions[actions.size() - 1];
+    const bool is_same_trans = (last_action.trans_id() == cur_action.trans_id());
+    const bool is_same_item = (last_action.item_id() == cur_action.item_id());
+    return
+        /* WW WR same item in same transaction is meaningless */
+        (is_same_trans && is_same_item &&
+         (Action::Type::WRITE == last_action.type() || Action::Type::READ == cur_action.type())) ||
+        /* actions for different items in same transaction can be swapped, so we support item_id
+           must be ascending */
+        (is_same_trans && last_action.item_id() > cur_action.item_id()) ||
+        /* read actions in different transactions can be swapped */
+        //(Action::Type::READ == last_action.type() && Action::Type::READ == cur_action.type() &&
+        // last_action.trans_id() > cur_action.trans_id()) ||
+        false;
+  }
+
+  bool TraversalActionSequenceCreator::OnlyOneTrans(const std::vector<Action> &actions) const {
+    for (uint64_t i = 1; i < actions.size(); ++i) {
+      if (actions[i].trans_id() != actions[i - 1].trans_id()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  void TraversalActionSequenceCreator::RecursiveFillDMLActionSeq(
+      const std::function<void(const ActionSequence &,uint64_t , const uint64_t)> &handle,
+      std::vector<Action> &actions, uint64_t max_trans_id, uint64_t max_item_id) const {
+    size_t cur = actions.size();
+    if (dynamic_seq_len_ || cur == dml_act_num_) {
+      if (dfs_cnt_ == subtask_num_) {
+        if (max_trans_id == trans_num_ || save_history_with_empty_opt_)
+          handle(ActionSequence(max_trans_id, item_num_, actions),seq_id_, max_trans_id);
+        else
+          cut_down_++;
+        dfs_cnt_ -= subtask_num_;
+      }
+      ++seq_id_;
+      ++dfs_cnt_;
+    }
+    if (cur != dml_act_num_) {
+      // Make sure trans id is increment
+      for (uint64_t trans_id = 0; trans_id < std::min(max_trans_id + 1, trans_num_); ++trans_id)
+        for (uint64_t item_id = 0; item_id < std::min(max_item_id + 1, item_num_); ++item_id)
+          for (Action::Type dml_act_type : {Action::Type::READ, Action::Type::WRITE}) {
+            // Continuous read in same transaction is meaningless
+            if (cur > 0 && dml_act_type == Action::Type::READ &&
+                dml_act_type == actions[cur - 1].type() &&
+                trans_id == actions[cur - 1].trans_id() && item_id == actions[cur - 1].item_id()) {
+              continue;
+            }
+            actions.emplace_back(dml_act_type, trans_id, item_id);
+            // if (!SkipDMLAction(actions)) { RecursiveFillDMLActionSeq(handle, actions, versions);
+            // }
+            RecursiveFillDMLActionSeq(handle, actions, std::max(trans_id + 1, max_trans_id),
+                                      std::max(item_id + 1, max_item_id));
+            actions.pop_back();
+          }
+    }
+  }
+  /*****************************************************************************
+   * Just like backtrace structure, condition-if includes the end-condition. And condition-else
+   *does the loop works. This function firstly build the Full Permutation of DTL. And then merge
+   *it with DML. At last handle() it. args: dtl_act_types: set of DTL
+   *
+   *
+   ****************************************************************************/
+  void TraversalActionSequenceCreator::RecursiveFillDTLActionSeq(const std::function<void(const ActionSequence &)> &handle,
+                                 std::vector<Action::Type> &dtl_act_types,
+                                 const uint64_t max_trans_id, uint64_t abort_trans_num) const {
+    if (!with_abort_) {
+      dtl_act_types.assign(max_trans_id, Action::Type::COMMIT);
+    }
+    if (dtl_act_types.size() == max_trans_id) {
+      std::vector<uint64_t> trans_order;
+      for (uint64_t trans_id = 0; trans_id < max_trans_id; ++trans_id) {
+        trans_order.push_back(trans_id);
+      }
+      do {
+        std::vector<Action> dtl_actions;
+        for (uint64_t trans_id : trans_order) {
+          dtl_actions.emplace_back(dtl_act_types[trans_id], trans_id);
+        }
+        handle(ActionSequence(max_trans_id, item_num_, dtl_actions, abort_trans_num));
+      } while (std::next_permutation(trans_order.begin(), trans_order.end()));
+    } else {
+      for (Action::Type dtl_act_type : {Action::Type::COMMIT, Action::Type::ABORT}) {
+        dtl_act_types.emplace_back(dtl_act_type);
+        if (dtl_act_type == Action::Type::ABORT) abort_trans_num++;
+        RecursiveFillDTLActionSeq(handle, dtl_act_types, max_trans_id, abort_trans_num);
+        dtl_act_types.pop_back();
+      }
+    }
+  }
+
+  void TraversalActionSequenceCreator::RecursiveMoveForwardDTLAction(const std::function<void(const ActionSequence &)> &handle,
+                                     ActionSequence &act_seq, const size_t pos) const {
+    if (pos == act_seq.size() || tail_dtl_) {
+      handle(act_seq);
+    } else {
+      RecursiveMoveForwardDTLAction(handle, act_seq, pos + 1);
+      size_t i = pos;
+      while (i > 0 && act_seq[i - 1].trans_id() != act_seq[i].trans_id() &&
+             (act_seq[i - 1].IsPointDML() || act_seq[i - 1].type() == Action::Type::SCAN_ODD)) {
+        std::swap(act_seq[i - 1], act_seq[i]);
+        RecursiveMoveForwardDTLAction(handle, act_seq, pos + 1);
+        --i;
+      }
+      while (i < pos) {
+        std::swap(act_seq[i], act_seq[i + 1]);
+        ++i;
+      }
+    }
+  }
diff --git a/benchmarks/creator.h b/benchmarks/creator.h
new file mode 100644
index 0000000..b9ad90d
--- /dev/null
+++ b/benchmarks/creator.h
@@ -0,0 +1,75 @@
+#pragma once
+#include <random>
+
+#include "generic.h"
+
+
+class ActionSequenceCreator {
+ public:
+  ActionSequenceCreator() {}
+  ~ActionSequenceCreator() {}
+  virtual void DeliverActionSequences(const std::function<void(ActionSequence &&,uint64_t)> &handle) const = 0;
+};
+
+class InputActionSequenceCreator : public ActionSequenceCreator {
+ public:
+  InputActionSequenceCreator(const std::string &path);
+  ~InputActionSequenceCreator();
+  virtual void DeliverActionSequences(
+      const std::function<void(ActionSequence &&,uint64_t)> &handle) const;
+
+ private:
+  const std::string path_;
+};
+
+
+
+
+class TraversalActionSequenceCreator : public ActionSequenceCreator {
+ public:
+  TraversalActionSequenceCreator(const Options &opt);
+
+  void DeliverActionSequences(const std::function<void(ActionSequence &&,uint64_t)> &handle) const;
+  static uint64_t cut_down_;
+
+
+ private:
+  void HandleActionSeq(const std::function<void(ActionSequence &&,uint64_t)> &handle,uint64_t seq_id,
+                       const ActionSequence &act_seq) const ;
+  void HandleDTLActionSeq(const std::function<void(ActionSequence &&,uint64_t)> &handle,uint64_t seq_id,
+                          const ActionSequence &dml_act_seq,
+                          const ActionSequence &dtl_act_seq) const ;
+  void HandleDMLActionSeq(const std::function<void(ActionSequence &&,uint64_t)> &handle,uint64_t seq_id,
+                          const ActionSequence &dml_act_seq, const uint64_t max_trans_id) const ;
+
+  bool SkipDMLAction(const std::vector<Action> &actions) const ;
+  bool OnlyOneTrans(const std::vector<Action> &actions) const ;
+  void RecursiveFillDMLActionSeq(
+      const std::function<void(const ActionSequence &,uint64_t , const uint64_t)> &handle,
+      std::vector<Action> &actions, uint64_t max_trans_id, uint64_t max_item_id) const ;
+  /*****************************************************************************
+   * Just like backtrace structure, condition-if includes the end-condition. And condition-else
+   *does the loop works. This function firstly build the Full Permutation of DTL. And then merge
+   *it with DML. At last handle() it. args: dtl_act_types: set of DTL
+   *
+   *
+   ****************************************************************************/
+  void RecursiveFillDTLActionSeq(const std::function<void(const ActionSequence &)> &handle,
+                                 std::vector<Action::Type> &dtl_act_types,
+                                 const uint64_t max_trans_id, uint64_t abort_trans_num) const ;
+
+  void RecursiveMoveForwardDTLAction(const std::function<void(const ActionSequence &)> &handle,
+                                     ActionSequence &act_seq, const size_t pos) const ;
+
+  const uint64_t trans_num_;
+  const uint64_t item_num_;
+  const uint64_t dml_act_num_;
+  const uint64_t subtask_num_;
+  mutable uint64_t dfs_cnt_;
+  const bool with_abort_;
+  const bool tail_dtl_;
+  const bool save_history_with_empty_opt_;
+  const bool dynamic_seq_len_;
+  mutable uint64_t seq_id_;
+
+};
diff --git a/benchmarks/da.h b/benchmarks/da.h
new file mode 100644
index 0000000..0bdd54f
--- /dev/null
+++ b/benchmarks/da.h
@@ -0,0 +1,65 @@
+#ifndef _DA_H_
+#define _DA_H_
+#include "config.h"
+#include "query.h"
+#include "row.h"
+#include "txn.h"
+#include "workload.h"
+#include "creator.h"
+
+class DAQuery;
+class DAQueryMessage;
+struct Item_no;
+
+class TableSchema;
+class INDEX;
+class DAQuery;
+
+class DAWorkload : public WLSchema {
+ public:
+  RC init();
+  RC init_table();
+  RC init_schema(const char* schema_file);
+  RC txn_get_manager(TxnMgr*& txn_manager);
+  void reset_tab_idx();
+  TableSchema* t_datab;
+	uint64_t nextstate;
+  INDEX* i_datab;
+  bool** delivering;
+
+ private:
+  //void init_tab_DAtab(int id, uint64_t w_id);
+  void init_tab_DAtab();
+  static void* threadInitDAtab(void* This);
+};
+
+struct DA_thr_args {
+  DAWorkload* wl;
+  UInt32 id;
+  UInt32 tot;
+};
+
+class DATxnManager : public TxnMgr {
+ public:
+  void init(uint64_t thd_id, WLSchema* h_wl);
+  void reset();
+  RC acquire_locks();
+  RC run_txn();
+  RC run_txn_post_wait();
+  RC run_calvin_txn();
+
+  void copy_remote_items(DAQueryMessage* msg);
+
+ private:
+  DAWorkload* _wl;
+  volatile RC _rc;
+  RowData* row;
+
+  uint64_t next_item_id;
+
+  bool is_done();
+  bool is_local_item(uint64_t idx);
+  RC send_remote_request() {return RCOK;}
+  RC run_delivery(DAQuery* query);
+};
+#endif
diff --git a/benchmarks/da_block_queue.cpp b/benchmarks/da_block_queue.cpp
new file mode 100644
index 0000000..66b776e
--- /dev/null
+++ b/benchmarks/da_block_queue.cpp
@@ -0,0 +1,82 @@
+
+#include "da_block_queue.h"
+
+
+void DABlockQueue::LockQueue()  //queue lock
+{
+    pthread_mutex_lock(&mutex);
+}
+void DABlockQueue::UnlockQueue()
+{
+    pthread_mutex_unlock(&mutex);
+}
+void DABlockQueue::ProductWait()
+{
+    pthread_cond_wait(&full,&mutex);
+}
+void DABlockQueue::ConsumeWait()
+{
+    pthread_cond_wait(&empty,&mutex);
+}
+void DABlockQueue::NotifyProduct()
+{
+    pthread_cond_signal(&full);
+}
+void DABlockQueue::NotifyConsume()
+{
+    pthread_cond_signal(&empty);
+}
+bool DABlockQueue::IsEmpty()
+{
+    return (q.size() == 0 ? true : false);
+}
+bool DABlockQueue::IsFull()
+{
+    return (q.size() == cap ? true : false);
+}
+
+DABlockQueue::DABlockQueue(size_t _cap = 50):cap(_cap)
+{
+    pthread_mutex_init(&mutex,NULL);
+    pthread_cond_init(&full,NULL);
+    pthread_cond_init(&empty,NULL);
+}
+DABlockQueue::~DABlockQueue()
+{
+    pthread_mutex_destroy(&mutex);
+    pthread_cond_destroy(&full);
+    pthread_cond_destroy(&empty);
+}
+void DABlockQueue::push_data(BaseQry* data)
+{
+    LockQueue();
+    while(IsFull())
+    {
+        NotifyConsume();
+        std::cout<<"queue full,notify consume data,product stop!!"<<std::endl;
+        ProductWait();
+    }
+
+    q.push_back(data);
+    NotifyConsume();
+    UnlockQueue();
+}
+BaseQry* DABlockQueue::pop_data()
+{
+    BaseQry* data;
+    LockQueue();
+    while(IsEmpty())
+    {
+        NotifyProduct();
+        std::cout<<"queue empty,notify product data,consume stop!!"<<std::endl;
+        list<BaseQry*>().swap(q);
+        ConsumeWait();
+    }
+
+    data = q.front();
+    q.pop_front();
+    NotifyProduct();
+    UnlockQueue();
+    return data;
+}
+
diff --git a/benchmarks/da_block_queue.h b/benchmarks/da_block_queue.h
new file mode 100644
index 0000000..048b51c
--- /dev/null
+++ b/benchmarks/da_block_queue.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "global.h"
+
+
+class DABlockQueue
+{
+    private:
+        //std::queue<BaseQry*> q;
+        std::list<BaseQry*> q;
+        size_t cap;
+        pthread_mutex_t mutex;
+        pthread_cond_t full;
+        pthread_cond_t empty;
+        void LockQueue();
+        void UnlockQueue();
+        void ProductWait();
+        void ConsumeWait();
+        void NotifyProduct();
+        void NotifyConsume();
+        bool IsEmpty();
+        bool IsFull();
+    public:
+        DABlockQueue(size_t _cnt);
+        ~DABlockQueue();
+        void push_data(BaseQry* data);
+        BaseQry* pop_data();
+};
diff --git a/benchmarks/da_const.h b/benchmarks/da_const.h
new file mode 100644
index 0000000..a03cb31
--- /dev/null
+++ b/benchmarks/da_const.h
@@ -0,0 +1,12 @@
+#pragma once
+
+enum {
+	X,
+	Y,
+	Z,
+	};
+
+enum{
+	ID,
+	VALUE
+};
diff --git a/benchmarks/da_query.cpp b/benchmarks/da_query.cpp
new file mode 100644
index 0000000..53934f6
--- /dev/null
+++ b/benchmarks/da_query.cpp
@@ -0,0 +1,132 @@
+
+#include "query.h"
+#include "da_query.h"
+#include "da.h"
+#include "mem_alloc.h"
+#include "workload.h"
+#include "table.h"
+#include "message.h"
+
+
+void DAQuery::init(uint64_t thd_id, WLSchema * h_wl){
+  BaseQry::init();
+}
+
+void DAQuery::init() {
+  BaseQry::init();
+}
+
+
+void DAQuery::release() {
+  BaseQry::release();
+}
+
+void DAQuery::print()
+{
+    std::cout<<
+    "trans_id:"<<trans_id<<" "
+		"item_id"<<item_id<<" "
+		"seq_id"<<seq_id<<" "
+		"state"<<state<<" "
+		"next_state"<<next_state<<" "
+		"last_state"<<last_state<<std::endl;
+}
+
+bool DAQuery::readonly()
+{
+    return false;
+}
+
+std::set<uint64_t> DAQuery::participants(Msg * msg, WLSchema * wl) {
+  std::set<uint64_t> participant_set;
+  return participant_set;
+}
+
+uint64_t DAQueryGenerator::action_2_state(ActionSequence& act_seq,size_t i, uint64_t seq_id)
+{
+
+  //turn to 64bit in order to not overflow
+  uint64_t ret=0, trans_id2=0, item_id2=0, type2=0, seq_id2=0, number2=0;
+  if(i<0||i>=act_seq.actions().size())
+    return ret;
+  trans_id2=act_seq.actions()[i].trans_id();
+  if(act_seq.actions()[i].IsPointDML())
+    item_id2=act_seq.actions()[i].item_id();
+  type2=static_cast<int>(act_seq.actions()[i].type());
+  seq_id2=seq_id;
+  number2=i;
+
+
+  ret = ret |  trans_id2;
+  ret = ret | (item_id2 <<  8 );
+  ret = ret | (type2    <<  16);
+  ret = ret | (seq_id2  <<  24);
+  ret = ret | (number2  <<  32);
+  return ret;
+}
+DATxnType type_trans(char type)
+{
+    if(type=='R')
+      return DA_READ;
+    else if(type=='W')
+      return DA_WRITE;
+    else if(type=='C')
+      return DA_COMMIT;
+    else if(type=='A')
+      return DA_ABORT;
+    else
+      return DA_SCAN;
+}
+uint64_t DAQueryGenerator::seq_num=0;
+BaseQry * DAQueryGenerator::create_query(WLSchema * h_wl, uint64_t home_partition_id)
+{
+  #if CREATOR_USE_T
+    struct Options opt;
+    opt.trans_num=TRANS_CNT;
+    opt.item_num=ITEM_CNT;
+    opt.subtask_num=SUBTASK_NUM;
+    opt.subtask_id=SUBTASK_ID;
+    if(opt.subtask_num>1)
+      opt.subtask_id=home_partition_id;
+    opt.max_dml=MAX_DML;
+    opt.with_abort=WITH_ABORT;
+    opt.tail_dtl=TAIL_DTL;
+    opt.save_history_with_empty_opt=SAVE_HISTROY_WITH_EMPTY_OPT;
+    opt.dynamic_seq_len=DYNAMIC_SEQ_LEN;
+    TraversalActionSequenceCreator creator(opt);
+  #else
+    InputActionSequenceCreator creator(string(INPUT_FILE_PATH));
+  #endif
+  BaseQry * ret=NULL;
+  const auto handle = [this](ActionSequence &&act_seq,uint64_t seq_id) {
+    size_t seq_size=act_seq.actions().size();
+    int* t_version=(int*)malloc(act_seq.item_num()*sizeof(int));
+    memset(t_version,0,act_seq.item_num()*sizeof(int));
+    //bool pu=false;
+    for(size_t i=0;i<seq_size;i++)
+    {
+        DAQuery * DAQ_t=new DAQuery();
+        DAQ_t->trans_id=act_seq.actions()[i].trans_id();
+        DAQ_t->item_id=act_seq.actions()[i].item_id();
+        DAQ_t->seq_id=seq_num;//*opt.subtask_num+opt.subtask_id;
+        DAQ_t->state=action_2_state(act_seq,i,DAQ_t->seq_id);
+        DAQ_t->next_state=action_2_state(act_seq,i+1,DAQ_t->seq_id);
+        DAQ_t->last_state=action_2_state(act_seq,i-1,DAQ_t->seq_id);
+        DAQ_t->txn_type=type_trans(static_cast<char>(act_seq.actions()[i].type()));
+        if(act_seq.actions()[i].type()==Action::Type::WRITE)
+          t_version[DAQ_t->item_id]++;
+        DAQ_t->write_version=t_version[DAQ_t->item_id];
+        da_gen_qry_queue.push_data(DAQ_t);
+
+    }
+    free(t_version);
+    seq_num++;
+    printf("product: %lu\n",seq_num);
+    fflush(stdout);
+  };
+
+  creator.DeliverActionSequences(handle);
+  printf("history thread exit\n");
+  fflush(stdout);
+  return ret;
+}
diff --git a/benchmarks/da_query.h b/benchmarks/da_query.h
new file mode 100644
index 0000000..990d575
--- /dev/null
+++ b/benchmarks/da_query.h
@@ -0,0 +1,50 @@
+#ifndef _DAQuery_H_
+#define _DAQuery_H_
+
+#include "global.h"
+#include "universal.h"
+#include "query.h"
+#include "da.h"
+//#include "creator.h"
+
+class WLSchema;
+class Msg;
+
+class DAQuery : public BaseQry {
+public:
+	DAQuery()
+	{
+		trans_id=0;
+		item_id=0;
+		seq_id=0;
+		state=0;
+		next_state=0;
+		last_state=0;
+	}
+  	void init();
+	void init(uint64_t thd_id, WLSchema * h_wl);
+  	void release();
+  	void print();
+  	bool readonly();
+
+	static std::set<uint64_t> participants(Msg * msg, WLSchema * wl);
+	DATxnType txn_type;
+	uint64_t trans_id;
+	uint64_t item_id;
+	uint64_t seq_id;
+	uint64_t write_version;
+	uint64_t state;
+	uint64_t next_state;
+	uint64_t last_state;
+
+
+};
+
+class DAQueryGenerator : public QryGenerator {
+public:
+  BaseQry * create_query(WLSchema * h_wl, uint64_t home_partition_id);
+  static uint64_t seq_num;
+private:
+  uint64_t action_2_state(ActionSequence& act_seq,size_t i, uint64_t seq_id);
+};
+#endif
diff --git a/benchmarks/da_query_queue.cpp b/benchmarks/da_query_queue.cpp
new file mode 100644
index 0000000..a91e38d
--- /dev/null
+++ b/benchmarks/da_query_queue.cpp
@@ -0,0 +1,16 @@
+
+/*#include"da_query_queue.h"
+#include"da_query.h"
+
+
+bool DAQueryQueue::push(DAQuery query)
+{
+    if(!queue.push(query))
+        return false;
+    else
+        return true;
+}
+int DAQueryQueue::pop();
+int DAQueryQueue::is_full();
+int DAQueryQueue::is_empty();
+*/
diff --git a/benchmarks/da_query_queue.h b/benchmarks/da_query_queue.h
new file mode 100644
index 0000000..5e0eea2
--- /dev/null
+++ b/benchmarks/da_query_queue.h
@@ -0,0 +1,14 @@
+/*#include <boost/lockfree/queue.hpp>
+
+
+class DAQueryQueue
+{
+    public:
+        bool push();
+        bool pop();
+        bool is_full();
+        bool is_empty();
+    private:
+        boost::lockfree::queue<int, boost::lockfree::fixed_sized<true>> q{100};
+        uint64_t size;
+};*/
diff --git a/benchmarks/da_schema.txt b/benchmarks/da_schema.txt
new file mode 100644
index 0000000..2a92709
--- /dev/null
+++ b/benchmarks/da_schema.txt
@@ -0,0 +1,7 @@
+//size,type,name
+TABLE=DAtab
+    8,int64_t,id
+    8,int64_t,value
+
+INDEX=DAtab_IDX
+        DAtab,0
diff --git a/benchmarks/da_txn.cpp b/benchmarks/da_txn.cpp
new file mode 100644
index 0000000..eac35ab
--- /dev/null
+++ b/benchmarks/da_txn.cpp
@@ -0,0 +1,195 @@
+#include <unistd.h>
+
+#include "config.h"
+#include "da.h"
+#include "da_const.h"
+#include "da_query.h"
+#include "IndexBTree.h"
+#include "IndexHash.h"
+#include "message.h"
+#include "msg_queue.h"
+#include "query.h"
+#include "row.h"
+#include "table.h"
+#include "thread.h"
+#include "transport.h"
+#include "workload.h"
+
+void DATxnManager::init(uint64_t thd_id, WLSchema *h_wl) {
+  TxnMgr::init(thd_id, h_wl);
+  _wl = (DAWorkload *)h_wl;
+  reset();
+}
+RC DATxnManager::run_txn_post_wait() {
+  get_row_post_wait(row);
+  return RCOK;
+}
+RC DATxnManager::acquire_locks(){return RCOK;}
+RC DATxnManager::run_calvin_txn(){return RCOK;}
+void DATxnManager::reset(){TxnMgr::reset();}
+RC DATxnManager::run_txn() {
+#if MODE == SETUP_MODE
+  return RCOK;
+#endif
+  RC rc = RCOK;
+  //uint64_t starttime = acquire_ts();
+  if(IS_LOCAL(txn->txn_id)) {
+    DEBUG("Running txn %ld\n",txn->txn_id);
+#if DISTR_DEBUG
+    query->print();
+#endif
+    query->parts_touched.add_unique(GET_PART_ID(0,g_node_id));
+  }
+
+  DAQuery *da_query = (DAQuery *)query;
+  uint64_t trans_id = da_query->trans_id;
+  uint64_t item_id = da_query->item_id;  // item_id from 0 to 2 represent X,Y,Z
+  //uint64_t seq_id = da_query->seq_id;
+  uint64_t state = da_query->state;
+  uint64_t version = da_query->write_version;
+  //uint64_t next_state = da_query->next_state;
+  //uint64_t last_state = da_query->last_state;
+  DATxnType txn_type = da_query->txn_type;
+  bool jump=false;
+
+  #if WORKLOAD ==DA
+    printf("thd_id:%lu check: state:%lu nextstate:%lu \n",h_thd->_thd_id, state, _wl->nextstate);
+    fflush(stdout);
+  #endif
+  if(_wl->nextstate!=0)
+  {
+    while (state != _wl->nextstate&&!simulate_man->is_done());
+  }
+
+  if(already_abort_tab.count(trans_id)>0)
+  {
+    if(txn_type==DA_WRITE || txn_type==DA_READ||txn_type==DA_COMMIT||txn_type==DA_ABORT)
+    {
+      jump=true;
+      if(txn_type==DA_ABORT)
+        INC_STATS(read_thd_id(), positive_txn_abort_cnt, 1);
+    }
+    //else if(txn_type==DA_COMMIT)
+      //txn_type=DA_ABORT;
+  }
+
+  if(!jump)
+  {
+    //enum RC { RCOK = 0, Commit, Abort, WAIT, WAIT_REM, ERROR, FINISH, NONE };
+      itemidData *item;
+      INDEX *index = _wl->i_datab;
+      uint64_t value[3];
+      RC rc2 = RCOK;
+      item = index_read(index, item_id, 0);
+      assert(item != NULL);
+      RowData *TempRow = ((RowData *)item->location);
+
+      switch (txn_type) {
+        case DA_WRITE: {
+          rc = get_row(TempRow, WR, row);
+          if(rc == RCOK)
+            row->set_value(VALUE, version);
+          else
+          {
+            rc2 = rc;
+            rc = start_abort();
+            already_abort_tab.insert(trans_id);
+          }
+          break;
+        }
+        case DA_READ: {
+          rc = get_row(TempRow, RD, row);
+          if(rc == RCOK)
+            row->get_row_value(VALUE, value[0]);
+          else
+          {
+            rc2 = rc;
+            rc = start_abort();
+            already_abort_tab.insert(trans_id);
+          }
+          break;
+        }
+        case DA_COMMIT: {
+          rc=start_commit();
+          break;
+        }
+        case DA_ABORT: {
+          INC_STATS(read_thd_id(), positive_txn_abort_cnt, 1);
+          rc = start_abort();
+          break;
+        }
+        case DA_SCAN: {
+          RowData *TempRow;
+          for (int i = 0; i < ITEM_CNT; i++) {
+            item = index_read(index, item_id, 0);
+            assert(item != NULL);
+            TempRow = ((RowData *)item->location);
+            rc = get_row(TempRow, WR, row);
+            row->get_row_value(VALUE, value[i]);
+          }
+          break;
+        }
+      }
+      if (rc == RCOK) {
+        switch (txn_type)
+        {
+          case DA_WRITE:
+            DA_history_mem.push_back('W');
+            break;
+          case DA_READ:
+            DA_history_mem.push_back('R');
+            break;
+          case DA_COMMIT:
+            DA_history_mem.push_back('C');
+            break;
+          case DA_ABORT:
+            DA_history_mem.push_back('A');
+            break;
+          case DA_SCAN:
+            DA_history_mem.push_back('S');
+            break;
+        }
+        DA_history_mem.push_back(static_cast<char>('0'+trans_id));//trans_id
+        if(txn_type==DA_WRITE || txn_type==DA_READ) {
+          DA_history_mem.push_back(static_cast<char>('a'+item_id));//item_id
+          DA_history_mem.push_back(static_cast<char>('='));//item_id
+          if (txn_type==DA_WRITE)
+            DA_history_mem.push_back(static_cast<char>('0'+version));//item_id
+          else if (txn_type==DA_READ)
+            DA_history_mem.push_back(static_cast<char>('0'+value[0]));//item_id
+        } 
+        DA_history_mem.push_back(' ');
+      } else if (rc == Commit) {
+        DA_history_mem.push_back('C');
+        DA_history_mem.push_back(static_cast<char>('0'+trans_id));//trans_id
+        DA_history_mem.push_back(' ');
+      } else {
+        if (rc2 == WAIT) {
+          DA_history_mem.push_back('W');
+          DA_history_mem.push_back('a');
+          DA_history_mem.push_back('i');
+          DA_history_mem.push_back('t');
+        }
+        else DA_history_mem.push_back('A');
+        DA_history_mem.push_back(static_cast<char>('0'+trans_id));//trans_id
+        DA_history_mem.push_back(' ');
+      }
+  }
+
+  _wl->nextstate = da_query->next_state;
+  if(_wl->nextstate==0)
+  {
+    if(abort_history)
+      abort_file<<DA_history_mem<<endl;
+    else
+      commit_file<<DA_history_mem<<endl;
+
+    string().swap(DA_history_mem);
+    abort_history=false;
+    da_start_stamp_tab.clear();
+    _wl->reset_tab_idx();
+    already_abort_tab.clear();
+    da_start_trans_tab.clear();
+  }
+  return rc;
+}
diff --git a/benchmarks/da_wl.cpp b/benchmarks/da_wl.cpp
new file mode 100644
index 0000000..fd78376
--- /dev/null
+++ b/benchmarks/da_wl.cpp
@@ -0,0 +1,95 @@
+#include "da.h"
+#include "da_const.h"
+#include "global.h"
+#include "universal.h"
+#include "IndexBTree.h"
+#include "IndexHash.h"
+#include "mem_alloc.h"
+#include "query.h"
+#include "row.h"
+#include "table.h"
+#include "thread.h"
+#include "txn.h"
+#include "workload.h"
+#include <string>
+
+RC DAWorkload::init() {
+  WLSchema::init();
+  char *cpath = getenv("SCHEMA_PATH");
+  string path;
+  if (cpath == NULL)
+    path = "./benchmarks/";
+  else {
+    path = string(cpath);
+  }
+  path += "da_schema.txt";
+  cout << "reading schema file: " << path << endl;
+  delivering = new bool *[g_wh_num + 1];
+  for (UInt32 wid = 1; wid <= g_wh_num; wid++)
+    delivering[wid] = (bool *)malloc(CL_SIZE);
+  printf("Initializing schema... ");
+  fflush(stdout);
+  init_schema(path.c_str());
+  printf("Done\n");
+  printf("Initializing table... ");
+  fflush(stdout);
+  init_table();
+  printf("Done\n");
+  fflush(stdout);
+  nextstate=0;
+  return RCOK;
+}
+
+RC DAWorkload::init_schema(const char *schema_file) {
+  WLSchema::init_schema(schema_file);
+  printf("base WLSchema init_schema over");
+  t_datab = tables["DAtab"];
+  i_datab = indexes["DAtab_IDX"];  //the name of index defined in da_schema.txt
+  return RCOK;
+}
+
+RC DAWorkload::init_table() {
+  //pthread_t *p_thds = new pthread_t[g_init_parallelism - 1];
+  DA_thr_args *tt = new DA_thr_args[g_init_parallelism];
+  for (UInt32 i = 0; i < g_init_parallelism; i++) {
+    tt[i].wl = this;
+    tt[i].id = i;
+  }
+  // DA table
+  threadInitDAtab(&tt[0]);
+  nextstate=0;
+  printf("DAtab Done\n");
+  return RCOK;
+}
+
+void DAWorkload::init_tab_DAtab() {
+  RowData *row;
+  uint64_t row_id;
+  for (int i = 0; i < ITEM_CNT; i++) {
+    t_datab->get_new_row(row, 0, row_id);
+    row->set_value(ID, i);
+    row->set_value(VALUE, 0);
+    //insert_row(row, _wl->t_datab);
+    index_insert(i_datab, i, row, 0);
+  }
+}
+
+void DAWorkload::reset_tab_idx()
+{
+  index_delete_all();
+  init_tab_DAtab();
+}
+
+void *DAWorkload::threadInitDAtab(void *This) {
+  DAWorkload *wl = ((DA_thr_args *)This)->wl;
+  wl->init_tab_DAtab();
+  return NULL;
+}
+
+RC DAWorkload::txn_get_manager(TxnMgr *&txn_manager) {
+  DEBUG_M("DAWorkload::txn_get_manager DATxnManager alloc\n");
+  txn_manager = (DATxnManager *)malloc(sizeof(DATxnManager));
+  new (txn_manager) DATxnManager();
+  // txn_manager->init( this);
+  return RCOK;
+}
diff --git a/benchmarks/generic.cpp b/benchmarks/generic.cpp
new file mode 100644
index 0000000..36066e9
--- /dev/null
+++ b/benchmarks/generic.cpp
@@ -0,0 +1,484 @@
+#include"generic.h"
+
+std::unordered_map<int, std::string> Anomally2Name=
+{
+  //I, II
+  {DIRTY_WRITE,"DIRTY_WRITE"},
+  {EDGE_CROESS,"EDGE_CROESS"},
+  {LOST_UPDATE,"LOST_UPDATE"},
+  {READ_SKEW,"READ_SKEW"},
+  {READ_WRITE_SKEW,"READ_WRITE_SKEW"},
+  {THREE_TRANS_WRITE_SKEW,"THREE_TRANS_WRITE_SKEW"},
+  {MULTI_TRANS_ANOMALY,"MULTI_TRANS_ANOMALY"},
+  //WSI
+  {WRITE_SKEW, "WRITE_SKEW"},
+  {WW_CONFLICT,"WW_CONFLICT"},
+  //SSI
+  {RW_CONFLICT,"RW_CONFLICT"},
+  //B F UNKNOWN
+  {UNKNOWN,"UNKNOWN"}
+};
+
+std::ostream& operator<<(std::ostream& os, const Anomally e) {
+  switch (e) {
+  case DIRTY_WRITE: \
+    return os << "DIRTY_WRITE";
+  case EDGE_CROESS: \
+    return os << "EDGE_CROESS";
+  case LOST_UPDATE: \
+    return os << "LOST_UPDATE";
+  case READ_SKEW: \
+    return os << "READ_SKEW";
+  case READ_WRITE_SKEW: \
+    return os << "READ_WRITE_SKEW";
+  case THREE_TRANS_WRITE_SKEW: \
+    return os << "THREE_TRANS_WRITE_SKEW";
+  case MULTI_TRANS_ANOMALY: \
+    return os << "MULTI_TRANS_ANOMALY";
+  case WRITE_SKEW: \
+    return os << "WRITE_SKEW";
+  case WW_CONFLICT: \
+    return os << "WW_CONFLICT";
+  case RW_CONFLICT: \
+    return os << "RW_CONFLICT";
+  default:
+      return os << "UNKNOWN";
+  }
+}
+
+
+enum class SerializeReadPolicy { UNCOMMITTED_READ, COMMITTED_READ, REPEATABLE_READ, SI_READ };
+
+template <typename T, typename... Ts>
+std::unique_ptr<T> MakeUnique(Ts&&... args) {
+  return std::unique_ptr<T>(new T(std::forward<Ts>(args)...));
+}
+
+	template <typename T>
+  Optional<T>::Optional() : has_value_(false), value_(nullptr) {}
+	template <typename T>
+  Optional<T>::Optional(const T& value) : has_value_(true), value_(new T(value)) {}
+	template <typename T>
+  Optional<T>::Optional(T&& value) : has_value_(true), value_(new T(std::forward<T>(value))) {}
+	template <typename T>
+  Optional<T>::Optional(const Optional<T>& o)
+      : has_value_(o.has_value_), value_(o.value_ ? new T(*o.value_) : nullptr) {}
+	template <typename T>
+  Optional<T>::Optional(Optional<T>&& o) = default;
+	template <typename T>
+  Optional<T>::~Optional() {}
+	template <typename T>
+  Optional<T>& Optional<T>::operator=(const Optional& o) {
+    has_value_ = o.has_value_;
+    value_ = o.value_ ? MakeUnique<T>(*o.value_) : nullptr;
+    return *this;
+  }
+	template <typename T>
+  Optional<T>& Optional<T>::operator=(Optional&&) = default;
+	template <typename T>
+  bool Optional<T>::HasValue() const { return has_value_; }
+	template <typename T>
+  void Optional<T>::Set(T&& value) {
+    value_ = MakeUnique<T>(std::move(value));
+    has_value_ = true;
+  }
+	template <typename T>
+  void Optional<T>::Set(const T& value) {
+    value_ = MakeUnique<T>(value);
+    has_value_ = true;
+  }
+	template <typename T>
+  T& Optional<T>::Get() {
+    if (!has_value_) {
+      throw "Empty Optional";
+    }
+    return *value_;
+  }
+	template <typename T>
+  const T& Optional<T>::Get() const {
+    if (!has_value_) {
+      throw "Empty Optional";
+    }
+    return *value_;
+  }
+
+
+
+
+  Action::Action() : type_(Type::UNKNOWN), trans_id_(0) {}
+  Action::Action(const Type dtl_type, const uint64_t trans_id) : type_(dtl_type), trans_id_(trans_id) {
+    if (!IsDTL()) {
+      throw std::to_string(static_cast<char>(dtl_type)) + " is not a DTL Action";
+    }
+  }
+  Action::Action(const Type dml_type, const uint64_t trans_id, const uint64_t item_id,
+         const Optional<uint64_t> version)
+      : type_(dml_type), trans_id_(trans_id), item_id_(item_id), version_(version) {
+    if (!IsPointDML()) {
+      throw std::to_string(static_cast<char>(dml_type)) + " is not a Point DML Action";
+    }
+  }
+  Action& Action::operator=(const Action& action) = default;
+  Action::~Action() {}
+
+  Action::Type Action::type() const { return type_; }
+  uint64_t Action::trans_id() const { return trans_id_; }
+  uint64_t Action::item_id() const {
+    if(item_id_.HasValue())
+      return item_id_.Get();
+    else
+      return 0;
+  }
+  uint64_t Action::version() const { return version_.Get(); }
+  void Action::SetTransId(uint64_t trans_id) { trans_id_ = trans_id; }
+  void Action::SetItemId(const uint64_t item_id) {
+    if (IsDTL()) {
+      throw "DTL actions update item id is meaningless";
+    }
+    item_id_.Set(item_id);
+  }
+  void Action::UpdateVersion(const uint64_t version) {
+    if (IsDTL()) {
+      throw "DML actions update version is meaningless";
+    }
+    version_.Set(version);
+  }
+
+  std::ostream& operator<<(std::ostream& os, const Action& action) {
+    os << static_cast<char>(action.type_) << action.trans_id_;
+    if (action.IsPointDML()) {
+      if (action.item_id_.Get() >= 26) {
+        throw "Not support item_id equal or larger than 26 yet";
+      }
+      os << static_cast<char>('a' + action.item_id_.Get());
+    }
+
+    return os;
+  }
+
+ std::istream& operator>>(std::istream& is, Action::Type& type) {
+    char c;
+    is >> c;
+    switch (c) {
+      case 'W':
+        type = Action::Type::WRITE;
+        break;
+      case 'R':
+        type = Action::Type::READ;
+        break;
+      case 'C':
+        type = Action::Type::COMMIT;
+        break;
+      case 'A':
+        type = Action::Type::ABORT;
+        break;
+      case 'S':
+        type = Action::Type::SCAN_ODD;
+        break;
+      default:
+        type = Action::Type::UNKNOWN;
+        is.setstate(std::ios::failbit);
+    }
+    return is;
+  }
+
+  std::istream& operator>>(std::istream& is, Action& action) {
+    if (!(is >> action.type_) || !(is >> action.trans_id_)) {
+      return is;
+    }
+    if (action.type_ == Action::Type::WRITE || action.type_ == Action::Type::READ) {
+      char item_c;
+      if (!(is >> item_c) || !std::islower(item_c)) {
+        is.setstate(std::ios::failbit);
+        return is;
+      }
+      action.item_id_ = item_c - 'a';
+    }
+    return is;
+  }
+
+  bool Action::IsPointDML() const { return IsPointDML(type_); }
+  bool Action::IsDTL() const { return IsDTL(type_); }
+  bool Action::IsPointDML(const Type& type) { return type == Type::READ || type == Type::WRITE; }
+  bool Action::IsDTL(const Type& type) { return type == Type::COMMIT || type == Type::ABORT; }
+  // surport std::map
+  bool Action::operator<(const Action& r) const {
+    if (trans_id() == r.trans_id()) {
+      uint64_t l_item_id = item_id_.HasValue() ? item_id() : -1;
+      uint64_t r_item_id = r.item_id_.HasValue() ? r.item_id() : -1;
+      if (l_item_id == r_item_id) {
+        uint64_t l_version = version_.HasValue() ? version() : -1;
+        uint64_t r_version = r.version_.HasValue() ? r.version() : -1;
+        if (l_version == r_version) return type() < r.type();
+        return l_version < r.version();
+      }
+      return l_item_id < r_item_id;
+    }
+    return trans_id() < r.trans_id();
+  }
+
+
+
+  ActionSequence::ActionSequence() : ActionSequence(0, 0, {}) {}
+  ActionSequence::ActionSequence(const uint64_t trans_num, const uint64_t item_num,
+                 const std::vector<Action>& actions)
+      : trans_num_(trans_num),abort_trans_num_(0), item_num_(item_num), actions_(actions) {}
+  ActionSequence::ActionSequence(const uint64_t trans_num, const uint64_t item_num, std::vector<Action>&& actions)
+      : trans_num_(trans_num), abort_trans_num_(0),item_num_(item_num), actions_(actions) {}
+  ActionSequence::ActionSequence(const uint64_t trans_num, const uint64_t item_num,
+                 const std::vector<Action>& actions, const uint64_t abort_trans_num)
+      : trans_num_(trans_num),
+        abort_trans_num_(abort_trans_num),
+        item_num_(item_num),
+        actions_(actions)
+         {}
+  ActionSequence::ActionSequence(ActionSequence&& act_seq) = default;
+  ActionSequence::ActionSequence(const ActionSequence& act_seq) = default;
+  ActionSequence::~ActionSequence() {}
+
+  ActionSequence& ActionSequence::operator=(ActionSequence&& act_seq) = default;
+  ActionSequence ActionSequence::operator+(const ActionSequence& act_seq) const {
+    if (trans_num_ != act_seq.trans_num_ || item_num_ != act_seq.item_num_) {
+      throw "Action sequence mismatch";
+    }
+    std::vector<Action> new_actions = actions_;
+    for (const auto& action : act_seq.actions_) {
+      new_actions.push_back(action);
+    }
+    return ActionSequence(trans_num_, item_num_, std::move(new_actions),
+                          abort_trans_num_ + act_seq.abort_trans_num_);
+  }
+  std::string ActionSequence::to_string() const {
+    std::string ret;
+    for (size_t i = 0; i < actions_.size(); i++) {
+      ret.push_back(static_cast<char>(actions_[i].type()));
+      ret.push_back('0' + actions_[i].trans_id());
+      if (actions_[i].IsPointDML()) ret.push_back('a' + actions_[i].item_id());
+    }
+    return ret;
+  }
+  std::vector<Action>& ActionSequence::actions() { return actions_; }
+  const std::vector<Action>& ActionSequence::actions() const { return actions_; }
+  uint64_t ActionSequence::trans_num() const { return trans_num_; }
+  uint64_t ActionSequence::abort_trans_num() const { return abort_trans_num_; }
+  uint64_t ActionSequence::item_num() const { return item_num_; }
+  size_t ActionSequence::size() const { return actions_.size(); }
+
+  std::ostream& operator<<(std::ostream& os, const ActionSequence& act_seq) {
+    for (const Action& action : act_seq.actions_) {
+      os << action << ' ';
+    }
+    return os;
+  }
+
+  std::istream& operator>>(std::istream& is, ActionSequence& act_seq) {
+    std::string s;
+    if (std::getline(is, s)) {
+      std::stringstream ss(s);
+      std::vector<Action> actions;
+      uint64_t trans_num = 0;
+      uint64_t item_num = 0;
+      for (std::stringstream ss(s); !ss.eof() && !ss.fail();) {
+        Action action;
+        if (ss >> action) {
+          actions.emplace_back(action);
+          trans_num = std::max(trans_num, action.trans_id() + 1);
+          if (action.IsPointDML()) {
+            item_num = std::max(item_num, action.item_id() + 1);
+          }
+        }
+      }
+      if (ss.fail()) {
+        std::cerr << "Invalid action sequence: \'" << s << "\'" << std::endl;
+      } else {
+        act_seq = ActionSequence(trans_num, item_num, actions);
+      }
+    }
+    return is;
+  }
+
+  Action& ActionSequence::operator[](const size_t index) { return actions_[index]; }
+
+  void ActionSequence::UpdateWriteVersions() {
+    std::vector<uint64_t> item_version(item_num_, 0);
+    for (Action& action : actions_) {
+      if (action.type() == Action::Type::WRITE) {
+        action.UpdateVersion(++item_version[action.item_id()]);
+      }
+    }
+  }
+  // add
+  // update write version, clean up read version
+  void ActionSequence::FillWriteVersions() {
+    std::vector<uint64_t> item_version(item_num_, 0);
+    for (Action& action : actions_) {
+      if (action.type() == Action::Type::WRITE) {
+        action.UpdateVersion(++item_version[action.item_id()]);
+      } else if (action.type() == Action::Type::READ) {
+        action.UpdateVersion(-1);  // clear read version as -1
+      }
+    }
+  }
+
+/*
+template <>
+void ActionSequence::FillReadVersions<SerializeReadPolicy::UNCOMMITTED_READ>(
+    ActionSequence& act_seq) {
+  std::vector<std::vector<Optional<uint64_t>>> trans_write_item_versions(
+      act_seq.trans_num(), std::vector<Optional<uint64_t>>(act_seq.item_num()));
+  std::vector<std::vector<Optional<uint64_t>>> item_version_link(
+      act_seq.item_num(), {0});
+
+  const auto latest_version = [&item_version_link](const uint64_t item_id) {
+    const std::vector<Optional<uint64_t>>& version_link = item_version_link[item_id];
+    uint64_t i = version_link.size() - 1;
+    for (; i >= 0 && !version_link[i].HasValue(); --i)
+      ;
+    assert(i < version_link.size());
+    return version_link[i].Get();
+  };
+  const auto release_version = [&item_version_link](const uint64_t item_id,
+                                                    const uint64_t version) {
+    for (Optional<uint64_t>& cur_version : item_version_link[item_id]) {
+      if (cur_version.HasValue() && cur_version.Get() == version) {
+        cur_version = {};
+        return;
+      }
+    }
+    assert(false);  // cannot found the version
+  };
+  for (Action& action : act_seq.actions()) {
+    if (action.type() == Action::Type::READ) {
+      // we did not change version when resort actions, so we use latest version instead of
+      // action.version()
+      // act_seq.PushTransReadResult(action.trans_id(), action.item_id(),
+      //                            latest_version(action.item_id()));
+      Optional<uint64_t> read_version =
+          trans_write_item_versions[action.trans_id()][action.item_id()];
+      if (read_version.HasValue()) {
+        action.UpdateVersion(read_version.Get());
+      } else
+        action.UpdateVersion(0);
+    } else if (action.type() == Action::Type::WRITE) {
+      item_version_link[action.item_id()].push_back(action.version());
+      Optional<uint64_t>& my_last_write_version =
+          trans_write_item_versions[action.trans_id()][action.item_id()];
+      if (my_last_write_version.HasValue()) {
+        release_version(action.item_id(), my_last_write_version.Get());
+      }
+      my_last_write_version = action.version();
+    } else if (action.type() == Action::Type::ABORT) {
+      for (uint64_t item_id = 0; item_id < act_seq.item_num(); ++item_id) {
+        const Optional<uint64_t>& my_last_write_version =
+            trans_write_item_versions[action.trans_id()][item_id];
+        if (my_last_write_version.HasValue()) {
+          release_version(item_id, my_last_write_version.Get());
+        }
+      }
+    } else if (action.type() == Action::Type::COMMIT) {
+    } else {
+      throw "Unexpected action type:" + std::to_string(static_cast<char>(action.type()));
+    }
+  }
+
+  std::vector<uint64_t> final_versions(act_seq.item_num());
+  for (uint64_t item_id = 0; item_id < act_seq.item_num(); ++item_id) {
+    final_versions[item_id] = latest_version(item_id);
+  }
+  // act_seq.SetItemFinalVersions(std::move(final_versions));
+}
+template <>
+void ActionSequence::FillReadVersions<SerializeReadPolicy::COMMITTED_READ>(
+    ActionSequence& act_seq) {
+  std::vector<std::vector<Optional<uint64_t>>> trans_write_item_versions(
+      act_seq.trans_num(), std::vector<Optional<uint64_t>>(act_seq.item_num()));
+  std::vector<uint64_t> latest_versions(act_seq.item_num(), 0);
+  for (Action& action : act_seq.actions()) {
+    if (action.type() == Action::Type::READ) {
+      Optional<uint64_t> read_version =
+          trans_write_item_versions[action.trans_id()][action.item_id()];
+      if (read_version.HasValue())
+        action.UpdateVersion(read_version.Get());
+      else
+        action.UpdateVersion(latest_versions[action.item_id()]);
+    } else if (action.type() == Action::Type::WRITE) {
+      trans_write_item_versions[action.trans_id()][action.item_id()] = action.version();
+    } else if (action.type() == Action::Type::ABORT) {
+    } else if (action.type() == Action::Type::COMMIT) {
+      for (uint64_t item_id = 0; item_id < act_seq.item_num(); item_id++) {
+        Optional<uint64_t> write_version = trans_write_item_versions[action.trans_id()][item_id];
+        if (write_version.HasValue()) {
+          latest_versions[item_id] = write_version.Get();
+        }
+      }
+    } else {
+      throw "Unexpected action type:" + std::to_string(static_cast<char>(action.type()));
+    }
+  }
+}
+template <>
+void ActionSequence::FillReadVersions<SerializeReadPolicy::REPEATABLE_READ>(
+    ActionSequence& act_seq) {
+  std::vector<std::vector<Optional<uint64_t>>> trans_read_item_versions(
+      act_seq.trans_num(), std::vector<Optional<uint64_t>>(act_seq.item_num()));
+  std::vector<std::vector<Optional<uint64_t>>> trans_write_item_versions(
+      act_seq.trans_num(), std::vector<Optional<uint64_t>>(act_seq.item_num()));
+  std::vector<uint64_t> latest_versions(act_seq.item_num(), 0);
+  for (Action& action : act_seq.actions()) {
+    if (action.type() == Action::Type::READ) {
+      const Optional<uint64_t>& write_version =
+          trans_write_item_versions[action.trans_id()][action.item_id()];
+      if (write_version.HasValue()) {  // item has written
+        action.UpdateVersion(write_version.Get());
+      } else {
+        Optional<uint64_t>& read_version =
+            trans_read_item_versions[action.trans_id()][action.item_id()];
+        if (!read_version.HasValue()) {  // item has read
+          read_version = latest_versions[action.item_id()];
+        }
+        action.UpdateVersion(read_version.Get());
+      }
+    } else if (action.type() == Action::Type::WRITE) {
+      trans_write_item_versions[action.trans_id()][action.item_id()] = action.version();
+    } else if (action.type() == Action::Type::ABORT) {
+    } else if (action.type() == Action::Type::COMMIT) {
+      for (uint64_t item_id = 0; item_id < act_seq.item_num(); item_id++) {
+        Optional<uint64_t> write_version = trans_write_item_versions[action.trans_id()][item_id];
+        if (write_version.HasValue()) {
+          latest_versions[item_id] = write_version.Get();
+        }
+      }
+    } else {
+      throw "Unexpected action type:" + std::to_string(static_cast<char>(action.type()));
+    }
+  }
+}
+template <>
+void ActionSequence::FillReadVersions<SerializeReadPolicy::SI_READ>(ActionSequence& act_seq) {
+  std::vector<uint64_t> latest_versions(act_seq.item_num(), 0);
+  std::vector<std::vector<uint64_t>> trans_item_versions_backup(act_seq.trans_num());
+  std::vector<std::vector<uint64_t>> trans_item_versions_snapshot(act_seq.trans_num());
+  for (Action& action : act_seq.actions()) {
+    if (trans_item_versions_snapshot[action.trans_id()].empty()) {
+      trans_item_versions_snapshot[action.trans_id()] = latest_versions;
+      trans_item_versions_backup[action.trans_id()] = latest_versions;
+    }
+    if (action.type() == Action::Type::READ) {
+      uint64_t read_version = trans_item_versions_snapshot[action.trans_id()][action.item_id()];
+      action.UpdateVersion(read_version);
+    } else if (action.type() == Action::Type::WRITE) {
+      trans_item_versions_snapshot[action.trans_id()][action.item_id()] = action.version();
+    } else if (action.type() == Action::Type::ABORT) {
+    } else if (action.type() == Action::Type::COMMIT) {
+      for (uint64_t item_id = 0; item_id < act_seq.item_num(); ++item_id) {
+        if (trans_item_versions_snapshot[action.trans_id()][item_id] !=
+            trans_item_versions_backup[action.trans_id()][item_id]) {
+          latest_versions[item_id] = trans_item_versions_snapshot[action.trans_id()][item_id];
+        }
+      }
+    } else {
+      throw "Unexpected action type:" + std::to_string(static_cast<char>(action.type()));
+    }
+  }
+}
+*/
diff --git a/benchmarks/generic.h b/benchmarks/generic.h
new file mode 100644
index 0000000..cabddbc
--- /dev/null
+++ b/benchmarks/generic.h
@@ -0,0 +1,178 @@
+#pragma once
+#include <sys/time.h>
+#include <unistd.h>
+
+#include <algorithm>
+#include <atomic>
+#include <cassert>
+#include <fstream>
+#include <functional>
+#include <iomanip>
+#include <iostream>
+#include <list>
+#include <map>
+#include <memory>
+#include <mutex>
+#include <set>
+#include <sstream>
+#include <string>
+#include <type_traits>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+
+
+enum Anomally
+{
+  //I, II
+  DIRTY_WRITE,
+  EDGE_CROESS,
+  LOST_UPDATE,
+  READ_SKEW,
+  READ_WRITE_SKEW,
+  THREE_TRANS_WRITE_SKEW,
+  MULTI_TRANS_ANOMALY,
+  //WSI
+  WRITE_SKEW,
+  WW_CONFLICT,
+  //SSI
+  RW_CONFLICT,
+  //B F UNKNOWN
+  UNKNOWN
+};
+
+extern std::unordered_map<int, std::string> Anomally2Name;
+
+
+std::ostream& operator<<(std::ostream& os, const Anomally e) ;
+
+
+enum class SerializeReadPolicy;
+
+template <typename T, typename... Ts>
+std::unique_ptr<T> MakeUnique(Ts&&... args) ;
+
+template <typename T>
+class Optional final {
+ public:
+  Optional();
+  Optional(const T& value);
+  Optional(T&& value);
+  Optional(const Optional<T>& o);
+  Optional(Optional<T>&& o);
+  ~Optional();
+  Optional<T>& operator=(const Optional& o);
+  Optional<T>& operator=(Optional&&);
+
+  bool HasValue() const;
+  void Set(T&& value) ;
+  void Set(const T& value) ;
+  T& Get();
+  const T& Get() const;
+
+ private:
+  bool has_value_;
+  std::unique_ptr<T> value_;
+};
+
+class Action {
+ public:
+  enum class Type : char {
+    UNKNOWN = '?',
+    READ = 'R',
+    WRITE = 'W',
+    COMMIT = 'C',
+    ABORT = 'A',
+    SCAN_ODD = 'S'
+  };
+  Action() ;
+  Action(const Type dtl_type, const uint64_t trans_id);
+  Action(const Type dml_type, const uint64_t trans_id, const uint64_t item_id,
+         const Optional<uint64_t> version = {});
+  Action& operator=(const Action& action);
+  virtual ~Action();
+
+  Type type() const;
+  uint64_t trans_id() const;
+  uint64_t item_id() const;
+  uint64_t version() const;
+  void SetTransId(uint64_t trans_id);
+  void SetItemId(const uint64_t item_id);
+  void UpdateVersion(const uint64_t version);
+
+  friend std::ostream& operator<<(std::ostream& os, const Action& action);
+
+  friend std::istream& operator>>(std::istream& is, Type& type);
+
+  friend std::istream& operator>>(std::istream& is, Action& action);
+
+  bool IsPointDML() const;
+  bool IsDTL() const;
+  static bool IsPointDML(const Type& type);
+  static bool IsDTL(const Type& type);
+  // surport std::map
+  bool operator<(const Action& r) const;
+ private:
+  Type type_;
+  uint64_t trans_id_;
+  Optional<uint64_t> item_id_;
+  Optional<uint64_t> version_;  // version_ identify a unique version, but it CANNOT be compared to
+                                // judge new or old
+};
+
+class ActionSequence {
+ public:
+  ActionSequence() ;
+  ActionSequence(const uint64_t trans_num, const uint64_t item_num,
+                 const std::vector<Action>& actions);
+  ActionSequence(const uint64_t trans_num, const uint64_t item_num, std::vector<Action>&& actions);
+  ActionSequence(const uint64_t trans_num, const uint64_t item_num,
+                 const std::vector<Action>& actions, const uint64_t abort_trans_num);
+  ActionSequence(ActionSequence&& act_seq);
+  ActionSequence(const ActionSequence& act_seq);
+  ~ActionSequence();
+
+  ActionSequence& operator=(ActionSequence&& act_seq);
+  ActionSequence operator+(const ActionSequence& act_seq) const;
+  std::string to_string() const;
+  std::vector<Action>& actions();
+  const std::vector<Action>& actions() const;
+  uint64_t trans_num() const;
+  uint64_t abort_trans_num() const;
+  uint64_t item_num() const;
+  size_t size() const;
+
+  friend std::ostream& operator<<(std::ostream& os, const ActionSequence& act_seq);
+
+  friend std::istream& operator>>(std::istream& is, ActionSequence& act_seq);
+
+  Action& operator[](const size_t index);
+  void UpdateWriteVersions();
+  // add
+  // update write version, clean up read version
+  void FillWriteVersions();
+  /*
+  template <SerializeReadPolicy>
+  inline void FillReadVersions(ActionSequence& act_seq);
+*/
+ private:
+  uint64_t trans_num_;
+  uint64_t abort_trans_num_;
+  uint64_t item_num_;  // 1
+  std::vector<Action> actions_;
+};
+
+struct Options {
+  uint64_t trans_num;
+  uint64_t item_num;
+
+  uint64_t subtask_num;
+  uint64_t subtask_id;
+  uint64_t max_dml;
+
+  bool with_abort;
+  bool tail_dtl;
+  bool save_history_with_empty_opt;
+  bool dynamic_seq_len;
+};
+
diff --git a/client/client_main.cpp b/client/client_main.cpp
index 6223bca..aad7081 100644
--- a/client/client_main.cpp
+++ b/client/client_main.cpp
@@ -1,6 +1,7 @@
 #include "global.h"
 #include "ycsb.h"
 #include "tpcc.h"
+#include "da.h"
 #include "test.h"
 #include "thread.h"
 #include "io_thread.h"
@@ -62,6 +63,8 @@ int main(int argc, char* argv[])
 			m_workload = new WLTPCC; break;
 		case TEST :
 			m_workload = new WLCTEST; break;
+		case DA :
+			m_workload = new DAWorkload; break;
 		default:
 			assert(false);
 	}
@@ -139,8 +142,8 @@ int main(int argc, char* argv[])
 	cpu_set_t cpus;
 	// spawn and run txns again.
 	begintime = get_serverdb_clock();
-  simulate_man->run_begintime = begintime;
-
+  	simulate_man->run_begintime = begintime;
+	simulate_man->last_da_query_time = begintime;
   uint64_t id = 0;
 	for (uint64_t i = 0; i < thd_cnt; i++) {
 		CPU_ZERO(&cpus);
diff --git a/client/client_query.cpp b/client/client_query.cpp
index f4f9fa1..5c66907 100644
--- a/client/client_query.cpp
+++ b/client/client_query.cpp
@@ -5,86 +5,111 @@
 #include "table.h"
 #include "qry_ycsb.h"
 #include "qry_tpcc.h"
-
+#include "da_query.h"
 
 /*************************************************/
 //     class Qry_queue
 /*************************************************/
 
+typedef struct
+{
+	void* context;
+	int thd_id;
+}FUNC_ARGS;
+
 void 
 Qry_queue_client::init(WLSchema * h_wl) {
 	_wl = h_wl;
 
 
 #if SERVER_GENERATE_QUERIES
-  if(ISCLIENT)
-    return;
-  size = g_thd_cnt;
+	if(ISCLIENT)
+		return;
+	size = g_thd_cnt;
 #else
-  size = g_servers_per_client;
+ 	size = g_servers_per_client;
+#endif
+	query_cnt = new uint64_t * [size];
+	for ( UInt32 id = 0; id < size; id ++) {
+		std::vector<BaseQry*> new_queries(g_per_part_max_txn+4,NULL);
+		queries.push_back(new_queries);
+		query_cnt[id] = (uint64_t*)alloc_memory.align_alloc(sizeof(uint64_t));
+	}
+	next_tid = 0;
+
+#if WORKLOAD == DA
+	FUNC_ARGS *arg=(FUNC_ARGS*)alloc_memory.align_alloc(sizeof(FUNC_ARGS));
+	arg->context=this;
+	arg->thd_id=g_init_parallelism - 1;
+	pthread_t  p_thds_main;
+	pthread_create(&p_thds_main, NULL, initQueriesHelper, (void*)arg );
+	pthread_detach(p_thds_main);
+#else
+	pthread_t * p_threads = new pthread_t[g_init_parallelism - 1];
+	for (UInt32 i = 0; i < g_init_parallelism - 1; i++) {
+		FUNC_ARGS *arg=(FUNC_ARGS*)mem_allocator.align_alloc(sizeof(FUNC_ARGS));
+		arg->context=this;
+		arg->thd_id=i;
+	  	pthread_create(&p_threads[i], NULL, initQueriesHelper,  (void*)arg);
+	}
+	FUNC_ARGS *arg=(FUNC_ARGS*)mem_allocator.align_alloc(sizeof(FUNC_ARGS));
+	arg->context=this;
+	arg->thd_id=g_init_parallelism - 1;
+	initQueriesHelper( (void*)arg);
+
+	for (uint32_t i = 0; i < g_init_parallelism - 1; i++) {
+	  pthread_join(p_threads[i], NULL);
+	}
 #endif
-  query_cnt = new uint64_t * [size];
-  for ( UInt32 id = 0; id < size; id ++) {
-    std::vector<BaseQry*> new_queries(g_per_part_max_txn+4,NULL);
-    queries.push_back(new_queries);
-    query_cnt[id] = (uint64_t*)alloc_memory.align_alloc(sizeof(uint64_t));
-  }
-  next_tid = 0;
-
-    pthread_t * p_threads = new pthread_t[g_init_parallelism - 1];
-    for (UInt32 i = 0; i < g_init_parallelism - 1; i++) {
-      pthread_create(&p_threads[i], NULL, initQueriesHelper, this);
-    }
-
-    initQueriesHelper(this);
-
-    for (uint32_t i = 0; i < g_init_parallelism - 1; i++) {
-      pthread_join(p_threads[i], NULL);
-    }
-
 
 }
 
 void * 
-Qry_queue_client::initQueriesHelper(void * context) {
-  ((Qry_queue_client*)context)->initQueriesParallel();
+Qry_queue_client::initQueriesHelper(void * args) {
+  ((Qry_queue_client*)((FUNC_ARGS*)args)->context)->initQueriesParallel(((FUNC_ARGS*)args)->thd_id);
   return NULL;
 }
 
 void 
-Qry_queue_client::initQueriesParallel() {
+Qry_queue_client::initQueriesParallel(uint64_t thd_id) {
+#if WORKLOAD != DA
 	UInt32 tid = ATOM_FETCH_ADD(next_tid, 1);
-  uint64_t request_cnt;
+  	uint64_t request_cnt;
 	request_cnt = g_per_part_max_txn + 4;
 	
-    uint32_t final_request;
-    if (tid == g_init_parallelism-1) {
-        final_request = request_cnt;
-    } else {
-        final_request = request_cnt / g_init_parallelism * (tid+1);
-    }
+	uint32_t final_request;
+	if (tid == g_init_parallelism-1) {
+		final_request = request_cnt;
+	} else {
+		final_request = request_cnt / g_init_parallelism * (tid+1);
+	}
+#endif
 
 #if WORKLOAD == YCSB	
-    QueryGenYCSB * gen = new QueryGenYCSB;
-    gen->init();
+	QueryGenYCSB * gen = new QueryGenYCSB;
+	gen->init();
 #elif WORKLOAD == TPCC
-    QueryGenTPCC * gen = new QueryGenTPCC;
+	QueryGenTPCC * gen = new QueryGenTPCC;
 #elif WORKLOAD == PPS
-    PPSQueryGenerator * gen = new PPSQueryGenerator;
+	PPSQueryGenerator * gen = new PPSQueryGenerator;
 #elif WORKLOAD == TEST
-    QueryGenTPCC * gen = new QueryGenTPCC;
+	QueryGenTPCC * gen = new QueryGenTPCC;
+#elif WORKLOAD == DA
+	DAQueryGenerator  * gen = new DAQueryGenerator;
 #endif
 #if SERVER_GENERATE_QUERIES
-  for ( UInt32 thd_id = 0; thd_id < g_thd_cnt; thd_id ++) {
-    for (UInt32 query_id = request_cnt / g_init_parallelism * tid; query_id < final_request; query_id ++) {
-      queries[thd_id][query_id] = gen->create_query(_wl,g_node_id);
-    }
+  for ( UInt32 thread_id = 0; thread_id < g_thd_cnt; thread_id ++) {
+	for (UInt32 query_id = request_cnt / g_init_parallelism * tid; query_id < final_request; query_id ++) {
+	  queries[thread_id][query_id] = gen->create_query(_wl,g_node_id);
+	}
   }
+#elif WORKLOAD == DA
+  gen->create_query(_wl,thd_id);
 #else
   for ( UInt32 server_id = 0; server_id < g_servers_per_client; server_id ++) {
-    for (UInt32 query_id = request_cnt / g_init_parallelism * tid; query_id < final_request; query_id ++) {
-      queries[server_id][query_id] = gen->create_query(_wl,server_id+g_server_start_node);
-    }
+	for (UInt32 query_id = request_cnt / g_init_parallelism * tid; query_id < final_request; query_id ++) {
+	  queries[server_id][query_id] = gen->create_query(_wl,server_id+g_server_start_node);
+	}
   }
 #endif
 
@@ -92,19 +117,25 @@ Qry_queue_client::initQueriesParallel() {
 
 bool
 Qry_queue_client::done() { 	
-  return false;
+  	return false;
 }
 
 BaseQry * 
 Qry_queue_client::get_next_query(uint64_t server_id,uint64_t thd_id) { 	
-  assert(server_id < size);
-  uint64_t query_id = __sync_fetch_and_add(query_cnt[server_id], 1);
-  if(query_id > g_per_part_max_txn) {
-    __sync_bool_compare_and_swap(query_cnt[server_id],query_id+1,0);
-    query_id = __sync_fetch_and_add(query_cnt[server_id], 1);
-  }
+#if WORKLOAD == DA
+  BaseQry * query;
+  query=da_gen_qry_queue.pop_data();
+  return query;
+#else
+	assert(server_id < size);
+	uint64_t query_id = __sync_fetch_and_add(query_cnt[server_id], 1);
+	if(query_id > g_per_part_max_txn) {
+		__sync_bool_compare_and_swap(query_cnt[server_id],query_id+1,0);
+		query_id = __sync_fetch_and_add(query_cnt[server_id], 1);
+	}
 	BaseQry * query = queries[server_id][query_id];
 	return query;
+#endif
 }
 
 
diff --git a/client/client_query.h b/client/client_query.h
index 88aaf08..81fe7ed 100644
--- a/client/client_query.h
+++ b/client/client_query.h
@@ -20,7 +20,7 @@ public:
 	void init(WLSchema * h_wl);
   bool done(); 
 	BaseQry * get_next_query(uint64_t server_id,uint64_t thd_id);
-  void initQueriesParallel();
+  void initQueriesParallel(uint64_t thd_id);
   static void * initQueriesHelper(void * context);
 	
 private:
diff --git a/commit_histroy.txt b/commit_histroy.txt
new file mode 100644
index 0000000..e69de29
diff --git a/commit_histroy_2pl.txt b/commit_histroy_2pl.txt
new file mode 100644
index 0000000..2794247
--- /dev/null
+++ b/commit_histroy_2pl.txt
@@ -0,0 +1,80 @@
+R0a=0 W0b=1 A1 W0b=2 R0c=0 A0 
+R0a=0 W0b=1 A1 W0b=2 R0c=0 C0 
+R0a=0 W0b=1 A1 A0 
+R0a=0 W0b=1 A1 A0 
+R0a=0 W0b=1 A1 R0c=0 W0a=1 R0b=1 C0 
+R0a=0 W0b=1 A1 W0b=3 A0 
+R0a=0 W0b=1 A1 W0b=3 C0 
+R0a=0 W0b=1 R1c=0 W0a=1 W1d=1 A1 W0d=2 A0 
+R0a=0 W0b=1 R1c=0 R0c=0 A1 R0a=0 C0 
+R0a=0 W0b=1 R1c=0 W0d=1 A1 A0 
+R0a=0 W0b=1 R1c=0 A1 W0d=1 C0 
+R0a=0 W0b=1 R1c=0 R1d=0 W0a=1 R1d=0 A0 A1 
+R0a=0 W0b=1 W1c=1 R0a=0 W1c=2 A0 R1b=0 A1 
+R0a=0 W0b=1 W1c=1 W0b=2 A1 R0d=0 C0 
+R0a=0 W0b=1 W1c=1 R0d=0 A1 W0b=2 C0 
+R0a=0 W0b=1 W1c=1 A1 R0d=0 A0 
+R0a=0 W0b=1 W1c=1 R1c=1 R0b=1 A0 A1 
+R0a=0 W0b=1 W1c=1 R1d=0 R1c=1 C0 R1b=1 C1 
+R0a=0 R1a=0 R0a=0 W0b=1 C0 R1c=0 R1a=0 A1 
+R0a=0 R1a=0 A0 R1a=0 C1 
+R0a=0 W1b=1 W0a=1 C0 R1a=1 R1c=0 W1b=2 A1 
+R0a=0 W1b=1 W0a=1 R1c=0 W1d=1 A0 W1c=1 C1 
+R0a=0 W1b=1 A0 W1c=1 C1 
+R0a=0 W1b=1 A0 W1a=1 A1 
+R0a=0 W1b=1 A0 W1c=1 A1 
+R0a=0 W1b=1 A1 W0b=2 W0b=3 R0b=3 R0c=0 A0 
+R0a=0 W1b=1 A0 R1a=0 A1 
+R0a=0 W1b=1 A0 R1c=0 R1b=1 A1 
+R0a=0 W1b=1 R0c=0 W0a=1 R0d=0 W0a=2 A1 C0 
+R0a=0 W1b=1 C1 R0c=0 W0c=1 W0a=1 R0d=0 C0 
+R0a=0 W1b=1 R0c=0 W0d=1 W1b=2 R0d=1 C0 C1 
+R0a=0 W1b=1 R0c=0 R1b=1 A1 W0d=1 C0 
+R0a=0 W1b=1 R0c=0 A1 W0d=1 R0c=0 A0 
+R0a=0 W1b=1 W0c=1 R0a=0 A0 W1d=1 C1 
+R0a=0 W1b=1 W0c=1 A0 W1d=1 R1b=1 C1 
+R0a=0 W1b=1 W0c=1 W0c=2 A1 R0d=0 A0 
+R0a=0 W1b=1 W0c=1 R1a=0 W0c=2 A0 A1 
+R0a=0 W1b=1 W0c=1 W1b=2 A0 W1d=1 A1 
+R0a=0 W1b=1 W0c=1 R1d=0 A1 R0b=0 W0a=1 A0 
+R0a=0 W1b=1 R1a=0 A0 W1a=2 W1a=3 A1 
+W0a=1 R0b=0 A1 W0a=2 R0a=2 A0 
+W0a=1 R0b=0 A1 W0c=1 W0b=2 A0 
+W0a=1 R0b=0 A1 C0 
+W0a=1 R0b=0 R1c=0 R0a=1 R1b=0 C1 W0c=1 C0 
+W0a=1 R0b=0 R1c=0 W0b=1 R0d=0 C0 W1c=1 A1 
+W0a=1 R0b=0 R1c=0 R0d=0 R0c=0 R1c=0 C1 A0 
+W0a=1 R0b=0 R1c=0 A1 W0b=1 W0a=3 A0 
+W0a=1 R0b=0 R1c=0 A1 W0d=1 A0 
+W0a=1 R0b=0 R1c=0 W1d=1 A1 R0d=0 A0 
+W0a=1 R0b=0 W1c=1 R0b=0 A0 C1 
+W0a=1 R0b=0 W1c=1 A0 C1 
+W0a=1 R0b=0 W1c=1 A1 W0a=2 W0a=3 C0 
+W0a=1 R0b=0 W1c=1 R1b=0 W1c=2 A0 R1d=0 C1 
+W0a=1 R0b=0 C0 W1c=1 W1c=2 W1a=2 R1b=0 A1 
+W0a=1 W0b=1 R0a=1 A0 W1a=3 R1b=0 C1 
+W0a=1 W0b=1 R0a=1 A1 C0 
+W0a=1 W0b=1 R0a=1 R1c=0 A0 W1c=1 R1b=0 C1 
+W0a=1 W0b=1 W0a=2 W0b=2 C0 R1c=0 W1c=1 A1 
+W0a=1 W0b=1 W0a=2 A1 R0c=0 R0a=2 A0 
+W0a=1 W0b=1 W0a=2 W1c=1 W1c=2 C1 W0b=2 C0 
+W0a=1 R1b=0 A0 R1b=0 A1 
+W0a=1 R1b=0 A0 W1a=2 A1 
+W0a=1 R1b=0 A0 W1c=1 R1a=0 A1 
+W0a=1 R1b=0 R0c=0 W0a=2 W1d=1 A1 A0 
+W0a=1 R1b=0 R0c=0 W0c=1 R1b=0 A1 W0a=2 A0 
+W0a=1 R1b=0 R0c=0 A1 R0d=0 R0a=1 C0 
+W0a=1 R1b=0 R0c=0 W1b=1 R0c=0 R1b=1 A1 A0 
+W0a=1 R1b=0 R0c=0 R1d=0 R0b=0 A1 C0 
+W0a=1 R1b=0 W0c=1 R0a=1 W1d=1 C1 R0d=1 C0 
+W0a=1 R1b=0 W0c=1 A0 R1a=0 C1 
+W0a=1 R1b=0 W0c=1 R0d=0 A0 W1a=2 A1 
+W0a=1 R1b=0 W0c=1 A1 W0a=3 R0b=0 C0 
+W0a=1 R1b=0 W0c=1 C0 W1b=1 R1d=0 W1a=2 C1 
+W0a=1 R1b=0 W0c=1 R1d=0 A1 R0d=0 A0 
+W0a=1 R1b=0 A1 R0b=0 A0 
+W0a=1 R1b=0 A1 W0b=1 W0a=3 A0 
+W0a=1 R1b=0 A1 R0c=0 C0 
+W0a=1 R1b=0 A1 R0b=0 C0 
+W0a=1 R1b=0 A1 R0b=0 C0 
+W0a=1 R1b=0 A1 W0b=1 R0b=1 A0 
diff --git a/commit_histroy_.txt b/commit_histroy_.txt
new file mode 100644
index 0000000..ca62586
--- /dev/null
+++ b/commit_histroy_.txt
@@ -0,0 +1,80 @@
+R0a=0 W0b=1 W1a=1 W1c=1 W0b=2 C1 R0c=1 A0 
+R0a=0 W0b=1 R1b=0 W0b=2 R0c=0 C0 W1a=1 A1 
+R0a=0 W0b=1 R1b=0 R1a=0 W1c=1 A0 W1c=2 A1 
+R0a=0 W0b=1 R1b=0 W1c=1 W1b=2 W1c=2 A0 A1 
+R0a=0 W0b=1 W1b=2 R0c=0 W0a=1 C1 R0b=1 C0 
+R0a=0 W0b=1 W1b=2 W1a=1 W1a=2 W0b=3 A0 A1 
+R0a=0 W0b=1 W1b=2 W1c=1 W0b=3 C0 W1a=1 C1 
+R0a=0 W0b=1 R1c=0 W0a=1 W1d=1 A1 W0d=2 A0 
+R0a=0 W0b=1 R1c=0 R0c=0 W1c=1 R0a=0 C1 A0 
+R0a=0 W0b=1 R1c=0 W0d=1 R1b=0 A0 R1a=0 A1 
+R0a=0 W0b=1 R1c=0 R1b=0 W0d=1 C0 R1a=0 A1 
+R0a=0 W0b=1 R1c=0 R1d=0 W0a=1 R1d=0 A0 A1 
+R0a=0 W0b=1 W1c=1 R0a=0 W1c=2 A0 R1b=0 A1 
+R0a=0 W0b=1 W1c=1 W0b=2 R1b=0 R0d=0 C0 A1 
+R0a=0 W0b=1 W1c=1 R0d=0 W1a=1 W0b=2 C0 C1 
+R0a=0 W0b=1 W1c=1 W1a=1 R0d=0 W1a=2 C1 A0 
+R0a=0 W0b=1 W1c=1 R1c=1 R0b=1 W0b=2 A1 A0 
+R0a=0 W0b=1 W1c=1 R1d=0 R1c=1 C0 R1b=1 A1 
+R0a=0 R1a=0 R0a=0 W0b=1 C0 R1c=0 R1a=0 A1 
+R0a=0 R1a=0 W0a=1 R0b=0 W0c=1 R1a=0 C0 A1 
+R0a=0 W1b=1 W0a=1 C0 R1a=1 R1c=0 W1b=2 A1 
+R0a=0 W1b=1 W0a=1 R1c=0 W1d=1 A0 W1c=1 C1 
+R0a=0 W1b=1 R0b=0 W0b=2 W1c=1 W0a=1 C1 A0 
+R0a=0 W1b=1 R0b=0 W1a=1 R0c=0 A1 R0a=0 C0 
+R0a=0 W1b=1 R0b=0 W1c=1 R0c=0 A1 R0b=0 C0 
+R0a=0 W1b=1 A1 W0b=2 W0b=3 R0b=3 R0c=0 A0 
+R0a=0 W1b=1 W0b=2 R1a=0 R0c=0 R0d=0 A1 A0 
+R0a=0 W1b=1 W0b=2 R1c=0 C0 R1b=1 W1b=3 C1 
+R0a=0 W1b=1 R0c=0 W0a=1 R0d=0 W0a=2 A1 C0 
+R0a=0 W1b=1 C1 R0c=0 W0c=1 W0a=1 R0d=0 C0 
+R0a=0 W1b=1 R0c=0 W0d=1 W1b=2 R0d=1 C0 C1 
+R0a=0 W1b=1 R0c=0 R1b=1 W1a=1 W0d=1 C0 A1 
+R0a=0 W1b=1 R0c=0 W1c=1 A1 W0d=1 R0c=0 A0 
+R0a=0 W1b=1 W0c=1 R0a=0 W0b=2 W1d=1 C1 A0 
+R0a=0 W1b=1 W0c=1 R0b=0 W1d=1 R1b=1 C1 A0 
+R0a=0 W1b=1 W0c=1 W0c=2 W1a=1 R0d=0 A0 C1 
+R0a=0 W1b=1 W0c=1 R1a=0 W0c=2 W0b=2 C0 A1 
+R0a=0 W1b=1 W0c=1 W1b=2 W0b=3 A0 W1d=1 A1 
+R0a=0 W1b=1 W0c=1 R1d=0 A1 R0b=0 W0a=1 A0 
+R0a=0 W1b=1 R1a=0 W0a=1 W1a=2 A0 W1a=3 A1 
+W0a=1 R0b=0 W1b=1 W0a=2 R0a=2 A0 W1a=3 A1 
+W0a=1 R0b=0 W1b=1 W0c=1 W0b=2 A0 R1b=1 A1 
+W0a=1 R0b=0 W1b=1 C0 W1b=2 R1b=2 W1c=1 C1 
+W0a=1 R0b=0 R1c=0 R0a=1 R1b=0 C1 W0c=1 C0 
+W0a=1 R0b=0 R1c=0 W0b=1 R0d=0 C0 W1c=1 A1 
+W0a=1 R0b=0 R1c=0 R0d=0 R0c=0 R1c=0 C1 A0 
+W0a=1 R0b=0 R1c=0 W1a=2 W0b=1 W0a=3 A0 A1 
+W0a=1 R0b=0 R1c=0 W1b=1 R1d=0 W0d=1 A1 A0 
+W0a=1 R0b=0 R1c=0 W1d=1 W1a=2 R0d=0 A0 C1 
+W0a=1 R0b=0 W1c=1 R0b=0 W0c=2 R0d=0 A0 C1 
+W0a=1 R0b=0 W1c=1 W0c=2 C1 W0b=1 W0c=3 A0 
+W0a=1 R0b=0 W1c=1 R1a=0 W0a=2 W0a=3 C0 A1 
+W0a=1 R0b=0 W1c=1 R1b=0 W1c=2 A0 R1d=0 C1 
+W0a=1 R0b=0 C0 W1c=1 W1c=2 W1a=2 R1b=0 A1 
+W0a=1 W0b=1 R0a=1 W0a=2 W1a=3 A0 R1b=0 C1 
+W0a=1 W0b=1 R0a=1 R1a=0 C0 R1b=1 R1c=0 A1 
+W0a=1 W0b=1 R0a=1 R1c=0 A0 W1c=1 R1b=0 C1 
+W0a=1 W0b=1 W0a=2 W0b=2 C0 R1c=0 W1c=1 A1 
+W0a=1 W0b=1 W0a=2 R1b=0 R0c=0 R0a=2 A1 A0 
+W0a=1 W0b=1 W0a=2 W1c=1 W1c=2 C1 W0b=2 C0 
+W0a=1 R1b=0 W0b=1 W0b=2 R1b=0 W0c=1 A1 A0 
+W0a=1 R1b=0 W0b=1 W1a=2 W0a=3 W0b=2 C0 A1 
+W0a=1 R1b=0 W0b=1 W1c=1 R0c=0 A0 R1a=0 A1 
+W0a=1 R1b=0 R0c=0 W0a=2 W1d=1 W1c=1 A1 A0 
+W0a=1 R1b=0 R0c=0 W0c=1 R1b=0 A1 W0a=2 A0 
+W0a=1 R1b=0 R0c=0 R1a=0 R0d=0 R0a=1 C0 A1 
+W0a=1 R1b=0 R0c=0 W1b=1 R0c=0 R1b=1 A1 A0 
+W0a=1 R1b=0 R0c=0 R1d=0 R0b=0 R1a=0 A1 C0 
+W0a=1 R1b=0 W0c=1 R0a=1 W1d=1 C1 R0d=1 A0 
+W0a=1 R1b=0 W0c=1 W0b=1 R1a=0 C1 R0c=1 A0 
+W0a=1 R1b=0 W0c=1 R0d=0 W0b=1 W1a=2 A0 A1 
+W0a=1 R1b=0 W0c=1 W1a=2 W0a=3 R0b=0 A1 C0 
+W0a=1 R1b=0 W0c=1 C0 W1b=1 R1d=0 W1a=2 C1 
+W0a=1 R1b=0 W0c=1 R1d=0 R1c=0 R0d=0 A0 C1 
+W0a=1 R1b=0 R1a=0 R0b=0 R1b=0 W1c=1 A0 C1 
+W0a=1 R1b=0 R1a=0 W1a=2 W0b=1 W0a=3 C1 A0 
+W0a=1 R1b=0 R1a=0 R1c=0 W1d=1 R0c=0 C1 C0 
+W0a=1 R1b=0 W1a=2 R0b=0 R1b=0 W1c=1 A1 C0 
+W0a=1 R1b=0 W1a=2 R1a=2 R0b=0 W1b=1 C0 A1 
+W0a=1 R1b=0 W1a=2 R1c=0 A1 W0b=1 R0b=1 A0 
diff --git a/commit_histroy_to.txt b/commit_histroy_to.txt
new file mode 100644
index 0000000..7a70f75
--- /dev/null
+++ b/commit_histroy_to.txt
@@ -0,0 +1,80 @@
+R0a=0 W0b=1 W1a=1 W1c=1 W0b=2 C1 A0 
+R0a=0 W0b=1 Wait1 W0b=2 R0c=0 C0 
+R0a=0 W0b=1 Wait1 A0 
+R0a=0 W0b=1 Wait1 A0 
+R0a=0 W0b=1 Wait1 R0c=0 W0a=1 R0b=1 C0 
+R0a=0 W0b=1 Wait1 W0b=3 A0 
+R0a=0 W0b=1 Wait1 W0b=3 C0 
+R0a=0 W0b=1 R1c=0 W0a=1 W1d=1 A1 A0 
+R0a=0 W0b=1 R1c=0 R0c=0 W1c=1 R0a=0 C1 C0 
+R0a=0 W0b=1 R1c=0 W0d=1 Wait1 A0 
+R0a=0 W0b=1 R1c=0 Wait1 W0d=1 C0 
+R0a=0 W0b=1 R1c=0 R1d=0 W0a=1 R1d=0 A0 A1 
+R0a=0 W0b=1 W1c=1 R0a=0 W1c=2 A0 R1b=0 A1 
+R0a=0 W0b=1 W1c=1 W0b=2 Wait1 R0d=0 C0 
+R0a=0 W0b=1 W1c=1 R0d=0 W1a=1 W0b=2 C0 C1 
+R0a=0 W0b=1 W1c=1 W1a=1 R0d=0 W1a=2 C1 A0 
+R0a=0 W0b=1 W1c=1 R1c=1 R0b=1 W0b=2 A1 A0 
+R0a=0 W0b=1 W1c=1 R1d=0 R1c=1 C0 R1b=1 C1 
+R0a=0 R1a=0 R0a=0 W0b=1 C0 R1c=0 R1a=0 A1 
+R0a=0 R1a=0 A0 R1a=0 C1 
+R0a=0 W1b=1 W0a=1 C0 R1a=1 R1c=0 W1b=2 A1 
+R0a=0 W1b=1 W0a=1 R1c=0 W1d=1 A0 W1c=1 C1 
+R0a=0 W1b=1 R0b=0 A0 W1c=1 C1 
+R0a=0 W1b=1 R0b=0 W1a=1 R0c=0 A1 R0a=0 C0 
+R0a=0 W1b=1 R0b=0 W1c=1 R0c=0 A1 R0b=0 C0 
+R0a=0 W1b=1 A1 A0 
+R0a=0 W1b=1 A0 R1a=0 A1 
+R0a=0 W1b=1 A0 R1c=0 R1b=1 W1b=3 C1 
+R0a=0 W1b=1 R0c=0 W0a=1 R0d=0 W0a=2 A1 C0 
+R0a=0 W1b=1 C1 R0c=0 W0c=1 W0a=1 R0d=0 C0 
+R0a=0 W1b=1 R0c=0 W0d=1 W1b=2 R0d=1 C0 C1 
+R0a=0 W1b=1 R0c=0 R1b=1 W1a=1 W0d=1 C0 A1 
+R0a=0 W1b=1 R0c=0 W1c=1 A1 W0d=1 R0c=0 A0 
+R0a=0 W1b=1 W0c=1 R0a=0 A0 W1d=1 C1 
+R0a=0 W1b=1 W0c=1 R0b=0 W1d=1 R1b=1 C1 C0 
+R0a=0 W1b=1 W0c=1 W0c=2 W1a=1 R0d=0 A0 C1 
+R0a=0 W1b=1 W0c=1 R1a=0 W0c=2 A0 A1 
+R0a=0 W1b=1 W0c=1 W1b=2 A0 W1d=1 A1 
+R0a=0 W1b=1 W0c=1 R1d=0 A1 R0b=0 W0a=1 A0 
+R0a=0 W1b=1 R1a=0 A0 W1a=2 W1a=3 A1 
+W0a=1 R0b=0 W1b=1 W0a=2 R0a=2 A0 W1a=3 A1 
+W0a=1 R0b=0 W1b=1 W0c=1 A0 R1b=1 A1 
+W0a=1 R0b=0 W1b=1 C0 W1b=2 R1b=2 W1c=1 C1 
+W0a=1 R0b=0 R1c=0 R0a=1 R1b=0 C1 A0 
+W0a=1 R0b=0 R1c=0 W0b=1 R0d=0 C0 W1c=1 A1 
+W0a=1 R0b=0 R1c=0 R0d=0 R0c=0 R1c=0 C1 A0 
+W0a=1 R0b=0 R1c=0 Wait1 W0b=1 W0a=3 A0 
+W0a=1 R0b=0 R1c=0 W1b=1 R1d=0 A0 A1 
+W0a=1 R0b=0 R1c=0 W1d=1 Wait1 R0d=0 A0 
+W0a=1 R0b=0 W1c=1 R0b=0 A0 C1 
+W0a=1 R0b=0 W1c=1 A0 C1 
+W0a=1 R0b=0 W1c=1 Wait1 W0a=2 W0a=3 C0 
+W0a=1 R0b=0 W1c=1 R1b=0 W1c=2 A0 R1d=0 C1 
+W0a=1 R0b=0 C0 W1c=1 W1c=2 W1a=2 R1b=0 A1 
+W0a=1 W0b=1 R0a=1 W0a=2 Wait1 A0 
+W0a=1 W0b=1 R0a=1 Wait1 C0 
+W0a=1 W0b=1 R0a=1 R1c=0 A0 W1c=1 R1b=0 C1 
+W0a=1 W0b=1 W0a=2 W0b=2 C0 R1c=0 W1c=1 A1 
+W0a=1 W0b=1 W0a=2 Wait1 R0c=0 R0a=2 A0 
+W0a=1 W0b=1 W0a=2 W1c=1 W1c=2 C1 W0b=2 C0 
+W0a=1 R1b=0 A0 R1b=0 A1 
+W0a=1 R1b=0 A0 W1a=2 A1 
+W0a=1 R1b=0 A0 W1c=1 R1a=0 A1 
+W0a=1 R1b=0 R0c=0 W0a=2 W1d=1 W1c=1 A1 A0 
+W0a=1 R1b=0 R0c=0 W0c=1 R1b=0 A1 W0a=2 A0 
+W0a=1 R1b=0 R0c=0 Wait1 R0d=0 R0a=1 C0 
+W0a=1 R1b=0 R0c=0 W1b=1 R0c=0 R1b=1 A1 A0 
+W0a=1 R1b=0 R0c=0 R1d=0 R0b=0 Wait1 C0 
+W0a=1 R1b=0 W0c=1 R0a=1 W1d=1 C1 A0 
+W0a=1 R1b=0 W0c=1 A0 R1a=0 C1 
+W0a=1 R1b=0 W0c=1 R0d=0 A0 W1a=2 A1 
+W0a=1 R1b=0 W0c=1 Wait1 W0a=3 R0b=0 C0 
+W0a=1 R1b=0 W0c=1 C0 W1b=1 R1d=0 W1a=2 C1 
+W0a=1 R1b=0 W0c=1 R1d=0 Wait1 R0d=0 A0 
+W0a=1 R1b=0 Wait1 R0b=0 A0 
+W0a=1 R1b=0 Wait1 A0 
+W0a=1 R1b=0 Wait1 R0c=0 C0 
+W0a=1 R1b=0 Wait1 R0b=0 C0 
+W0a=1 R1b=0 Wait1 R0b=0 C0 
+W0a=1 R1b=0 Wait1 A0 
diff --git a/commit_histroy_wait_die.txt b/commit_histroy_wait_die.txt
new file mode 100644
index 0000000..4001170
--- /dev/null
+++ b/commit_histroy_wait_die.txt
@@ -0,0 +1,80 @@
+R0a=0 W0b=1 A1 W0b=2 R0c=0 A0 
+R0a=0 W0b=1 A1 W0b=2 R0c=0 C0 
+R0a=0 W0b=1 A1 A0 
+R0a=0 W0b=1 A1 A0 
+R0a=0 W0b=1 A1 R0c=0 W0a=1 R0b=1 C0 
+R0a=0 W0b=1 A1 W0b=3 A0 
+R0a=0 W0b=1 A1 W0b=3 C0 
+R0a=0 W0b=1 R1c=0 W0a=1 W1d=1 A1 W0d=2 A0 
+R0a=0 W0b=1 R1c=0 R0c=0 A1 R0a=0 C0 
+R0a=0 W0b=1 R1c=0 W0d=1 A1 A0 
+R0a=0 W0b=1 R1c=0 A1 W0d=1 C0 
+R0a=0 W0b=1 R1c=0 R1d=0 W0a=1 R1d=0 A0 A1 
+R0a=0 W0b=1 W1c=1 R0a=0 W1c=2 A0 R1b=0 A1 
+R0a=0 W0b=1 W1c=1 W0b=2 A1 R0d=0 C0 
+R0a=0 W0b=1 W1c=1 R0d=0 A1 W0b=2 C0 
+R0a=0 W0b=1 W1c=1 A1 R0d=0 A0 
+R0a=0 W0b=1 W1c=1 R1c=1 R0b=1 W0b=2 A1 A0 
+R0a=0 W0b=1 W1c=1 R1d=0 R1c=1 C0 R1b=1 C1 
+R0a=0 R1a=0 R0a=0 W0b=1 C0 R1c=0 R1a=0 A1 
+R0a=0 R1a=0 Wait0 R1a=0 C1 
+R0a=0 W1b=1 W0a=1 C0 R1a=1 R1c=0 W1b=2 A1 
+R0a=0 W1b=1 W0a=1 R1c=0 W1d=1 A0 W1c=1 C1 
+R0a=0 W1b=1 Wait0 W1c=1 C1 
+R0a=0 W1b=1 Wait0 W1a=1 A1 
+R0a=0 W1b=1 Wait0 W1c=1 A1 
+R0a=0 W1b=1 A1 W0b=2 W0b=3 R0b=3 R0c=0 A0 
+R0a=0 W1b=1 Wait0 R1a=0 A1 
+R0a=0 W1b=1 Wait0 R1c=0 R1b=1 W1b=3 C1 
+R0a=0 W1b=1 R0c=0 W0a=1 R0d=0 W0a=2 A1 C0 
+R0a=0 W1b=1 C1 R0c=0 W0c=1 W0a=1 R0d=0 C0 
+R0a=0 W1b=1 R0c=0 W0d=1 W1b=2 R0d=1 C0 C1 
+R0a=0 W1b=1 R0c=0 R1b=1 A1 W0d=1 C0 
+R0a=0 W1b=1 R0c=0 A1 W0d=1 R0c=0 A0 
+R0a=0 W1b=1 W0c=1 R0a=0 Wait0 W1d=1 C1 
+R0a=0 W1b=1 W0c=1 Wait0 W1d=1 R1b=1 C1 
+R0a=0 W1b=1 W0c=1 W0c=2 A1 R0d=0 A0 
+R0a=0 W1b=1 W0c=1 R1a=0 W0c=2 Wait0 A1 
+R0a=0 W1b=1 W0c=1 W1b=2 Wait0 W1d=1 A1 
+R0a=0 W1b=1 W0c=1 R1d=0 A1 R0b=0 W0a=1 A0 
+R0a=0 W1b=1 R1a=0 Wait0 W1a=2 W1a=3 A1 
+W0a=1 R0b=0 A1 W0a=2 R0a=2 A0 
+W0a=1 R0b=0 A1 W0c=1 W0b=2 A0 
+W0a=1 R0b=0 A1 C0 
+W0a=1 R0b=0 R1c=0 R0a=1 R1b=0 C1 W0c=1 C0 
+W0a=1 R0b=0 R1c=0 W0b=1 R0d=0 C0 W1c=1 A1 
+W0a=1 R0b=0 R1c=0 R0d=0 R0c=0 R1c=0 C1 A0 
+W0a=1 R0b=0 R1c=0 A1 W0b=1 W0a=3 A0 
+W0a=1 R0b=0 R1c=0 A1 W0d=1 A0 
+W0a=1 R0b=0 R1c=0 W1d=1 A1 R0d=0 A0 
+W0a=1 R0b=0 W1c=1 R0b=0 Wait0 C1 
+W0a=1 R0b=0 W1c=1 Wait0 C1 
+W0a=1 R0b=0 W1c=1 A1 W0a=2 W0a=3 C0 
+W0a=1 R0b=0 W1c=1 R1b=0 W1c=2 A0 R1d=0 C1 
+W0a=1 R0b=0 C0 W1c=1 W1c=2 W1a=2 R1b=0 A1 
+W0a=1 W0b=1 R0a=1 W0a=2 A1 A0 
+W0a=1 W0b=1 R0a=1 A1 C0 
+W0a=1 W0b=1 R0a=1 R1c=0 A0 W1c=1 R1b=0 C1 
+W0a=1 W0b=1 W0a=2 W0b=2 C0 R1c=0 W1c=1 A1 
+W0a=1 W0b=1 W0a=2 A1 R0c=0 R0a=2 A0 
+W0a=1 W0b=1 W0a=2 W1c=1 W1c=2 C1 W0b=2 C0 
+W0a=1 R1b=0 Wait0 R1b=0 A1 
+W0a=1 R1b=0 Wait0 W1a=2 A1 
+W0a=1 R1b=0 Wait0 W1c=1 R1a=0 A1 
+W0a=1 R1b=0 R0c=0 W0a=2 W1d=1 A1 A0 
+W0a=1 R1b=0 R0c=0 W0c=1 R1b=0 A1 W0a=2 A0 
+W0a=1 R1b=0 R0c=0 A1 R0d=0 R0a=1 C0 
+W0a=1 R1b=0 R0c=0 W1b=1 R0c=0 R1b=1 A1 A0 
+W0a=1 R1b=0 R0c=0 R1d=0 R0b=0 A1 C0 
+W0a=1 R1b=0 W0c=1 R0a=1 W1d=1 C1 R0d=1 C0 
+W0a=1 R1b=0 W0c=1 Wait0 R1a=0 C1 
+W0a=1 R1b=0 W0c=1 R0d=0 Wait0 W1a=2 A1 
+W0a=1 R1b=0 W0c=1 A1 W0a=3 R0b=0 C0 
+W0a=1 R1b=0 W0c=1 C0 W1b=1 R1d=0 W1a=2 C1 
+W0a=1 R1b=0 W0c=1 R1d=0 A1 R0d=0 A0 
+W0a=1 R1b=0 A1 R0b=0 A0 
+W0a=1 R1b=0 A1 W0b=1 W0a=3 A0 
+W0a=1 R1b=0 A1 R0c=0 C0 
+W0a=1 R1b=0 A1 R0b=0 C0 
+W0a=1 R1b=0 A1 R0b=0 C0 
+W0a=1 R1b=0 A1 W0b=1 R0b=1 A0 
diff --git a/concurrency_control/row_mvcc.cpp b/concurrency_control/row_mvcc.cpp
new file mode 100755
index 0000000..811f7d3
--- /dev/null
+++ b/concurrency_control/row_mvcc.cpp
@@ -0,0 +1,38 @@
+
+#include "row.h"
+#include "txn.h"
+#include "row_mvcc.h"
+#include "mem_alloc.h"
+#include "manager.h"
+#include "universal.h"
+
+void Row_mvcc::init() {
+  	latch = (pthread_mutex_t *)alloc_memory.alloc(sizeof(pthread_mutex_t));
+	pthread_mutex_init(latch, NULL);
+	row_version_len = 0;
+}
+
+RC Row_mvcc::clear_version_list(access_t type, ts_t ts) {
+	RC rc = RCOK;
+	return rc;
+}
+
+
+void Row_mvcc::insert_version(ts_t ts, RowData *row) {
+
+}
+
+RC Row_mvcc::access(access_t type, TxnMgr * txn, RowData * row) {
+	RC rc = RCOK;
+	return rc;
+}
+
+RC commit(access_t type, TxnMgr * txn, RowData * data) {
+	RC rc = RCOK;
+	return rc;
+}
+
+RC abort(access_t type, TxnMgr * txn){
+	RC rc = RCOK;
+	return rc;
+}
\ No newline at end of file
diff --git a/concurrency_control/row_mvcc.h b/concurrency_control/row_mvcc.h
new file mode 100755
index 0000000..8aece64
--- /dev/null
+++ b/concurrency_control/row_mvcc.h
@@ -0,0 +1,60 @@
+
+#ifndef ROW_MVCC_H
+#define ROW_MVCC_H
+
+typedef uint64_t ts_t; // used for timestamp
+
+// corresponding versions of a record, using a linked list.
+struct RowVersionEntry {
+	ts_t ts;	// commit timestamp
+	RowData *version_data;	// data
+	RowVersionEntry * next;	// pointer to the next version according to version chain
+	RowVersionEntry * prev;  // pointer to the previous version
+};
+
+class Row_mvcc {
+public:
+	void init(); // init function
+	/*
+	 * access() function:
+	 * To read or write a particular version of this record, 
+	 * as well as do concurrency control.
+	 */
+	RC access(access_t type, TxnMgr * txn, RowData * row);
+	/*
+	 * commit() function:
+	 * To be called when a transaction is committing.
+	 * It may include two parts:
+	 * 1. Call insert_version() to write a new version, which can also be called in access()
+	 *    instead.
+	 * 2. Call clear_version_list() to cleanup outdated version.
+	 */
+	RC commit(access_t type, TxnMgr * txn, RowData * data);
+	/*
+	 * abort() function:
+	 * To be called when a transaction is aborting.
+	 * It may include two parts:
+	 * 1. Cleanup the intermediate version that is produced when processing a transaction.
+	 * 2. Call clear_version_list() to cleanup outdated version.
+	 */
+	RC abort(access_t type, TxnMgr * txn);
+
+private:
+ 	pthread_mutex_t * latch;
+	/*
+	 * insert_version() function:
+	 * To insert a new version.
+	 */
+	void insert_version(ts_t ts, RowData * row);
+	/*
+	 * clear_version_list() function:
+	 * To clean up outdated versions in the version chain.
+	 */
+	RC clear_version_list(access_t type, ts_t ts);
+
+    RowVersionEntry * row_version_list;	// version chain
+	uint64_t row_version_len;		// length of version chain
+	
+};
+
+#endif
diff --git a/config.h b/config.h
index 7a57fa5..7b09cb1 100644
--- a/config.h
+++ b/config.h
@@ -3,19 +3,39 @@
 #define _CONFIG_H_
 
 /***********************************************/
+// DA Trans Creator
+/***********************************************/
+//which creator to use
+#define CREATOR_USE_T false
+
+//TraversalActionSequenceCreator
+#define TRANS_CNT 2
+#define ITEM_CNT 4
+#define SUBTASK_NUM 1
+#define SUBTASK_ID 0
+#define MAX_DML 4
+#define WITH_ABORT false
+#define TAIL_DTL false
+#define SAVE_HISTROY_WITH_EMPTY_OPT false
+#define DYNAMIC_SEQ_LEN false
+
+//InputActionSequenceCreator
+#define INPUT_FILE_PATH "./input.txt"
+
+/***********************************************/
 // Simulation + Hardware
 /***********************************************/
 #define NODE_CNT 1
-#define THREAD_CNT 4
+#define THREAD_CNT 1
 #define REM_THREAD_CNT THREAD_CNT
 #define SEND_THREAD_CNT THREAD_CNT
 #define CORE_CNT 8
 // PART_CNT should be at least NODE_CNT
 #define PART_CNT NODE_CNT
 #define CLIENT_NODE_CNT NODE_CNT
-#define CLIENT_THREAD_CNT 4
-#define CLIENT_REM_THREAD_CNT 2
-#define CLIENT_SEND_THREAD_CNT 2
+#define CLIENT_THREAD_CNT 1
+#define CLIENT_REM_THREAD_CNT 1
+#define CLIENT_SEND_THREAD_CNT 1
 #define CLIENT_RUNTIME false
 
 #define LOAD_METHOD LOAD_MAX
@@ -37,7 +57,7 @@
 // # of transactions to run for warmup
 #define WARMUP            0
 // YCSB or TPCC or TEST
-#define WORKLOAD TEST
+#define WORKLOAD DA
 // print the transaction latency distribution
 #define PRT_LAT_DISTR false
 #define STATS_ENABLE        true
@@ -213,6 +233,16 @@ enum TPCCTxnType {TPCC_ALL,
           TPCC_DELIVERY, 
           TPCC_STOCK_LEVEL};
 extern TPCCTxnType          g_tpcc_txn_type;
+
+enum DATxnType {
+  DA_READ,
+  DA_WRITE,
+  DA_COMMIT,
+  DA_ABORT,
+  DA_SCAN
+};
+#define MAX_DA_TABLE_SIZE 10000
+
 #define TEST_ALL					true
 enum TestCases {
 	READ_WRITE,
@@ -238,7 +268,7 @@ extern TestCases					g_test_case;
 #define DEBUG_TIMESTAMP       false
 #define DEBUG_SYNTH         false
 #define DEBUG_ASSERT        false
-#define DEBUG_DISTR true
+#define DEBUG_DISTR false
 #define DEBUG_ALLOC false
 #define DEBUG_RACE false
 #define DEBUG_TIMELINE        false
@@ -266,6 +296,7 @@ extern TestCases					g_test_case;
 #define YCSB            1
 #define TPCC            2
 #define TEST            3
+#define DA            4
 // Concurrency Control Algorithm
 #define DL_DETECT         3
 #define HSTORE            7
@@ -274,6 +305,7 @@ extern TestCases					g_test_case;
 #define CALVIN      10
 #define TEMPLATE      11
 #define WDL           12
+#define MVCC          14
 // TIMESTAMP allocation method.
 #define TS_MUTEX          1
 #define TS_CAS            2
diff --git a/input.txt b/input.txt
new file mode 100644
index 0000000..ae7c47d
--- /dev/null
+++ b/input.txt
@@ -0,0 +1,80 @@
+R0a W0b W1a W1c W0b C1 R0c A0 
+R0a W0b R1b W0b R0c C0 W1a A1 
+R0a W0b R1b R1a W1c A0 W1c A1 
+R0a W0b R1b W1c W1b W1c A0 A1 
+R0a W0b W1b R0c W0a C1 R0b C0 
+R0a W0b W1b W1a W1a W0b A0 A1 
+R0a W0b W1b W1c W0b C0 W1a C1 
+R0a W0b R1c W0a W1d A1 W0d A0 
+R0a W0b R1c R0c W1c R0a C1 C0 
+R0a W0b R1c W0d R1b A0 R1a A1 
+R0a W0b R1c R1b W0d C0 R1a C1 
+R0a W0b R1c R1d W0a R1d A0 A1 
+R0a W0b W1c R0a W1c A0 R1b A1 
+R0a W0b W1c W0b R1b R0d C0 C1 
+R0a W0b W1c R0d W1a W0b C0 C1 
+R0a W0b W1c W1a R0d W1a C1 A0 
+R0a W0b W1c R1c R0b W0b A1 A0 
+R0a W0b W1c R1d R1c C0 R1b C1 
+R0a R1a R0a W0b C0 R1c R1a A1 
+R0a R1a W0a R0b W0c R1a C0 C1
+R0a W1b W0a C0 R1a R1c W1b A1 
+R0a W1b W0a R1c W1d A0 W1c C1 
+R0a W1b R0b W0b W1c W0a C1 A0 
+R0a W1b R0b W1a R0c A1 R0a C0 
+R0a W1b R0b W1c R0c A1 R0b C0 
+R0a W1b A1 W0b W0b R0b R0c A0 
+R0a W1b W0b R1a R0c R0d A1 A0 
+R0a W1b W0b R1c C0 R1b W1b C1 
+R0a W1b R0c W0a R0d W0a A1 C0 
+R0a W1b C1 R0c W0c W0a R0d C0 
+R0a W1b R0c W0d W1b R0d C0 C1 
+R0a W1b R0c R1b W1a W0d C0 A1 
+R0a W1b R0c W1c A1 W0d R0c A0 
+R0a W1b W0c R0a W0b W1d C1 A0 
+R0a W1b W0c R0b W1d R1b C1 C0 
+R0a W1b W0c W0c W1a R0d A0 C1 
+R0a W1b W0c R1a W0c W0b C0 A1 
+R0a W1b W0c W1b W0b A0 W1d A1 
+R0a W1b W0c R1d A1 R0b W0a A0 
+R0a W1b R1a W0a W1a A0 W1a A1 
+W0a R0b W1b W0a R0a A0 W1a A1 
+W0a R0b W1b W0c W0b A0 R1b A1 
+W0a R0b W1b C0 W1b R1b W1c C1 
+W0a R0b R1c R0a R1b C1 W0c C0 
+W0a R0b R1c W0b R0d C0 W1c A1 
+W0a R0b R1c R0d R0c R1c C1 A0 
+W0a R0b R1c W1a W0b W0a A0 A1 
+W0a R0b R1c W1b R1d W0d A1 A0 
+W0a R0b R1c W1d W1a R0d A0 C1 
+W0a R0b W1c R0b W0c R0d A0 C1 
+W0a R0b W1c W0c C1 W0b W0c A0 
+W0a R0b W1c R1a W0a W0a C0 C1 
+W0a R0b W1c R1b W1c A0 R1d C1 
+W0a R0b C0 W1c W1c W1a R1b A1 
+W0a W0b R0a W0a W1a A0 R1b C1 
+W0a W0b R0a R1a C0 R1b R1c C1 
+W0a W0b R0a R1c A0 W1c R1b C1 
+W0a W0b W0a W0b C0 R1c W1c A1 
+W0a W0b W0a R1b R0c R0a A1 A0 
+W0a W0b W0a W1c W1c C1 W0b C0 
+W0a R1b W0b W0b R1b W0c A1 A0 
+W0a R1b W0b W1a W0a W0b C0 A1 
+W0a R1b W0b W1c R0c A0 R1a A1 
+W0a R1b R0c W0a W1d W1c A1 A0 
+W0a R1b R0c W0c R1b A1 W0a A0 
+W0a R1b R0c R1a R0d R0a C0 C1 
+W0a R1b R0c W1b R0c R1b A1 A0 
+W0a R1b R0c R1d R0b R1a A1 C0 
+W0a R1b W0c R0a W1d C1 R0d C0 
+W0a R1b W0c W0b R1a C1 R0c A0 
+W0a R1b W0c R0d W0b W1a A0 A1 
+W0a R1b W0c W1a W0a R0b A1 C0 
+W0a R1b W0c C0 W1b R1d W1a C1 
+W0a R1b W0c R1d R1c R0d A0 C1 
+W0a R1b R1a R0b R1b W1c A0 C1 
+W0a R1b R1a W1a W0b W0a C1 A0 
+W0a R1b R1a R1c W1d R0c C1 C0 
+W0a R1b W1a R0b R1b W1c A1 C0 
+W0a R1b W1a R1a R0b W1b C0 A1 
+W0a R1b W1a R1c A1 W0b R0b A0
\ No newline at end of file
diff --git a/obj/deps b/obj/deps
index f7e4ace..6a9e185 100644
--- a/obj/deps
+++ b/obj/deps
@@ -1,358 +1,433 @@
 obj/config.o: config.cpp config.h
+obj/da_wl.o: benchmarks/da_wl.cpp benchmarks/da.h config.h system/query.h \
+ system/global.h statistics/stats.h statistics/stats_array.h \
+ system/pool.h system/universal.h system/concurrentqueue.h \
+ system/txn_table.h system/logMan.h system/sim_manager.h \
+ benchmarks/da_block_queue.h system/global.h system/array.h \
+ system/mem_alloc.h storage/row.h system/txn.h system/workload.h \
+ benchmarks/creator.h benchmarks/generic.h benchmarks/da_const.h \
+ system/universal.h storage/IndexBTree.h storage/IndexBase.h \
+ storage/IndexHash.h system/mem_alloc.h storage/table.h system/thread.h
 obj/qry_tpcc.o: benchmarks/qry_tpcc.cpp system/query.h system/global.h \
  config.h statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/array.h system/mem_alloc.h \
- benchmarks/qry_tpcc.h system/global.h system/universal.h \
- benchmarks/tpcc.h system/workload.h system/txn.h storage/row.h \
- benchmarks/universal_tpcc.h system/mem_alloc.h storage/table.h \
- transport/message.h system/logMan.h system/array.h
-obj/txn_ycsb.o: benchmarks/txn_ycsb.cpp system/global.h config.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/array.h system/mem_alloc.h benchmarks/qry_tpcc.h \
+ system/universal.h benchmarks/tpcc.h system/workload.h system/txn.h \
+ storage/row.h benchmarks/universal_tpcc.h system/mem_alloc.h \
+ storage/table.h transport/message.h system/logMan.h system/array.h
+obj/wl_tpcc.o: benchmarks/wl_tpcc.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/global.h system/universal.h system/concurrentqueue.h \
  system/txn_table.h system/logMan.h system/sim_manager.h \
- system/universal.h benchmarks/ycsb.h system/workload.h system/txn.h \
- system/array.h system/mem_alloc.h benchmarks/qry_ycsb.h system/query.h \
- system/array.h system/thread.h storage/table.h storage/row.h \
+ benchmarks/da_block_queue.h system/universal.h benchmarks/tpcc.h \
+ system/workload.h system/txn.h system/array.h system/mem_alloc.h \
+ system/query.h storage/row.h system/thread.h storage/table.h \
  storage/IndexHash.h storage/IndexBase.h storage/IndexBTree.h \
- storage/catalog.h system/manager.h system/mem_alloc.h system/msg_queue.h \
- system/lock_free_queue.h transport/message.h system/logMan.h
+ benchmarks/universal_tpcc.h system/mem_alloc.h benchmarks/const_tpcc.h
 obj/wl_ycsb.o: benchmarks/wl_ycsb.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/global.h system/universal.h system/concurrentqueue.h \
  system/txn_table.h system/logMan.h system/sim_manager.h \
- system/universal.h benchmarks/ycsb.h system/workload.h system/txn.h \
- system/array.h system/mem_alloc.h system/thread.h storage/table.h \
- storage/row.h storage/IndexHash.h storage/IndexBase.h \
+ benchmarks/da_block_queue.h system/universal.h benchmarks/ycsb.h \
+ system/workload.h system/txn.h system/array.h system/mem_alloc.h \
+ system/thread.h storage/table.h storage/row.h storage/IndexHash.h \
+ storage/IndexBase.h storage/IndexBTree.h storage/catalog.h \
+ system/manager.h system/mem_alloc.h system/query.h
+obj/txn_ycsb.o: benchmarks/txn_ycsb.cpp system/global.h config.h \
+ statistics/stats.h statistics/stats_array.h system/pool.h \
+ system/global.h system/universal.h system/concurrentqueue.h \
+ system/txn_table.h system/logMan.h system/sim_manager.h \
+ benchmarks/da_block_queue.h system/universal.h benchmarks/ycsb.h \
+ system/workload.h system/txn.h system/array.h system/mem_alloc.h \
+ benchmarks/qry_ycsb.h system/query.h system/array.h system/thread.h \
+ storage/table.h storage/row.h storage/IndexHash.h storage/IndexBase.h \
  storage/IndexBTree.h storage/catalog.h system/manager.h \
- system/mem_alloc.h system/query.h
-obj/txn_ctest.o: benchmarks/txn_ctest.cpp benchmarks/test.h system/workload.h \
+ system/mem_alloc.h system/msg_queue.h system/lock_free_queue.h \
+ transport/message.h system/logMan.h
+obj/wl_ctest.o: benchmarks/wl_ctest.cpp benchmarks/test.h system/workload.h \
  system/global.h config.h statistics/stats.h statistics/stats_array.h \
  system/pool.h system/universal.h system/concurrentqueue.h \
- system/txn_table.h system/logMan.h system/sim_manager.h system/txn.h \
- system/array.h system/mem_alloc.h system/global.h storage/row.h
+ system/txn_table.h system/logMan.h system/sim_manager.h \
+ benchmarks/da_block_queue.h system/global.h system/txn.h system/array.h \
+ system/mem_alloc.h storage/table.h storage/row.h system/mem_alloc.h \
+ storage/IndexHash.h system/universal.h storage/IndexBase.h \
+ storage/IndexBTree.h system/thread.h
+obj/generic.o: benchmarks/generic.cpp benchmarks/generic.h
+obj/da_query_queue.o: benchmarks/da_query_queue.cpp
 obj/universal_tpcc.o: benchmarks/universal_tpcc.cpp \
  benchmarks/universal_tpcc.h system/global.h config.h statistics/stats.h \
  statistics/stats_array.h system/pool.h system/global.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/universal.h
-obj/wl_ctest.o: benchmarks/wl_ctest.cpp benchmarks/test.h system/workload.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/universal.h
+obj/txn_ctest.o: benchmarks/txn_ctest.cpp benchmarks/test.h system/workload.h \
  system/global.h config.h statistics/stats.h statistics/stats_array.h \
  system/pool.h system/universal.h system/concurrentqueue.h \
- system/txn_table.h system/logMan.h system/sim_manager.h system/txn.h \
- system/array.h system/mem_alloc.h system/global.h storage/table.h \
- storage/row.h system/mem_alloc.h storage/IndexHash.h system/universal.h \
- storage/IndexBase.h storage/IndexBTree.h system/thread.h
-obj/wl_tpcc.o: benchmarks/wl_tpcc.cpp system/global.h config.h \
- statistics/stats.h statistics/stats_array.h system/pool.h \
- system/global.h system/universal.h system/concurrentqueue.h \
  system/txn_table.h system/logMan.h system/sim_manager.h \
- system/universal.h benchmarks/tpcc.h system/workload.h system/txn.h \
- system/array.h system/mem_alloc.h system/query.h storage/row.h \
- system/thread.h storage/table.h storage/IndexHash.h storage/IndexBase.h \
- storage/IndexBTree.h benchmarks/universal_tpcc.h system/mem_alloc.h \
- benchmarks/const_tpcc.h
-obj/qry_ycsb.o: benchmarks/qry_ycsb.cpp system/query.h system/global.h \
- config.h statistics/stats.h statistics/stats_array.h system/pool.h \
- system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/array.h system/mem_alloc.h \
- benchmarks/qry_ycsb.h system/global.h system/universal.h system/array.h \
- system/mem_alloc.h system/workload.h benchmarks/ycsb.h system/txn.h \
- storage/table.h transport/message.h system/logMan.h
+ benchmarks/da_block_queue.h system/global.h system/txn.h system/array.h \
+ system/mem_alloc.h storage/row.h
 obj/txn_tpcc.o: benchmarks/txn_tpcc.cpp benchmarks/tpcc.h system/workload.h \
  system/global.h config.h statistics/stats.h statistics/stats_array.h \
  system/pool.h system/universal.h system/concurrentqueue.h \
- system/txn_table.h system/logMan.h system/sim_manager.h system/txn.h \
- system/array.h system/mem_alloc.h system/query.h storage/row.h \
- system/global.h benchmarks/qry_tpcc.h system/universal.h \
- benchmarks/universal_tpcc.h system/thread.h storage/table.h \
- storage/IndexHash.h storage/IndexBase.h storage/IndexBTree.h \
- benchmarks/const_tpcc.h transport/transport.h transport/nn.hpp \
- system/msg_queue.h system/lock_free_queue.h transport/message.h \
- system/logMan.h system/array.h
-obj/test_wl.o: benchmarks/test_wl.cpp benchmarks/test.h system/workload.h \
- system/global.h config.h statistics/stats.h statistics/stats_array.h \
+ system/txn_table.h system/logMan.h system/sim_manager.h \
+ benchmarks/da_block_queue.h system/global.h system/txn.h system/array.h \
+ system/mem_alloc.h system/query.h storage/row.h benchmarks/qry_tpcc.h \
+ system/universal.h benchmarks/universal_tpcc.h system/thread.h \
+ storage/table.h storage/IndexHash.h storage/IndexBase.h \
+ storage/IndexBTree.h benchmarks/const_tpcc.h transport/transport.h \
+ transport/nn.hpp system/msg_queue.h system/lock_free_queue.h \
+ transport/message.h system/logMan.h system/array.h
+obj/da_block_queue.o: benchmarks/da_block_queue.cpp \
+ benchmarks/da_block_queue.h system/global.h config.h statistics/stats.h \
+ statistics/stats_array.h system/pool.h system/global.h \
+ system/universal.h system/concurrentqueue.h system/txn_table.h \
+ system/logMan.h system/sim_manager.h
+obj/da_txn.o: benchmarks/da_txn.cpp config.h benchmarks/da.h system/query.h \
+ system/global.h statistics/stats.h statistics/stats_array.h \
  system/pool.h system/universal.h system/concurrentqueue.h \
- system/txn_table.h system/logMan.h system/sim_manager.h system/txn.h \
- system/array.h system/mem_alloc.h system/global.h storage/table.h \
- storage/row.h system/mem_alloc.h storage/IndexHash.h system/universal.h \
- storage/IndexBase.h storage/IndexBTree.h system/thread.h
+ system/txn_table.h system/logMan.h system/sim_manager.h \
+ benchmarks/da_block_queue.h system/global.h system/array.h \
+ system/mem_alloc.h storage/row.h system/txn.h system/workload.h \
+ benchmarks/creator.h benchmarks/generic.h benchmarks/da_const.h \
+ benchmarks/da_query.h system/universal.h storage/IndexBTree.h \
+ storage/IndexBase.h storage/IndexHash.h transport/message.h \
+ system/logMan.h system/array.h system/msg_queue.h \
+ system/lock_free_queue.h storage/table.h system/thread.h \
+ transport/transport.h transport/nn.hpp
+obj/qry_ycsb.o: benchmarks/qry_ycsb.cpp system/query.h system/global.h \
+ config.h statistics/stats.h statistics/stats_array.h system/pool.h \
+ system/universal.h system/concurrentqueue.h system/txn_table.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/array.h system/mem_alloc.h benchmarks/qry_ycsb.h \
+ system/universal.h system/array.h system/mem_alloc.h system/workload.h \
+ benchmarks/ycsb.h system/txn.h storage/table.h transport/message.h \
+ system/logMan.h
+obj/creator.o: benchmarks/creator.cpp benchmarks/creator.h \
+ benchmarks/generic.h
+obj/da_query.o: benchmarks/da_query.cpp system/query.h system/global.h \
+ config.h statistics/stats.h statistics/stats_array.h system/pool.h \
+ system/universal.h system/concurrentqueue.h system/txn_table.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/array.h system/mem_alloc.h benchmarks/da_query.h \
+ system/universal.h benchmarks/da.h storage/row.h system/txn.h \
+ system/workload.h benchmarks/creator.h benchmarks/generic.h \
+ system/mem_alloc.h storage/table.h transport/message.h system/logMan.h \
+ system/array.h
 obj/client_query.o: client/client_query.cpp client/client_query.h \
  system/global.h config.h statistics/stats.h statistics/stats_array.h \
  system/pool.h system/global.h system/universal.h \
  system/concurrentqueue.h system/txn_table.h system/logMan.h \
- system/sim_manager.h system/universal.h system/query.h system/array.h \
- system/mem_alloc.h system/mem_alloc.h system/workload.h storage/table.h \
- benchmarks/qry_ycsb.h system/array.h benchmarks/qry_tpcc.h
+ system/sim_manager.h benchmarks/da_block_queue.h system/universal.h \
+ system/query.h system/array.h system/mem_alloc.h system/mem_alloc.h \
+ system/workload.h storage/table.h benchmarks/qry_ycsb.h system/array.h \
+ benchmarks/qry_tpcc.h benchmarks/da_query.h benchmarks/da.h \
+ storage/row.h system/txn.h benchmarks/creator.h benchmarks/generic.h
 obj/client_txn.o: client/client_txn.cpp client/client_txn.h system/global.h \
  config.h statistics/stats.h statistics/stats_array.h system/pool.h \
  system/global.h system/universal.h system/concurrentqueue.h \
  system/txn_table.h system/logMan.h system/sim_manager.h \
- system/mem_alloc.h
-obj/_template.o: concurrency_control/_template.cpp system/global.h \
- config.h statistics/stats.h statistics/stats_array.h system/pool.h \
- system/global.h system/universal.h system/concurrentqueue.h \
- system/txn_table.h system/logMan.h system/sim_manager.h \
- system/universal.h system/txn.h system/array.h system/mem_alloc.h \
- concurrency_control/_template.h storage/row.h system/manager.h \
- system/mem_alloc.h concurrency_control/row__template.h
+ benchmarks/da_block_queue.h system/mem_alloc.h
 obj/row__template.o: concurrency_control/row__template.cpp \
  storage/row.h system/global.h config.h statistics/stats.h \
  statistics/stats_array.h system/pool.h system/global.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/txn.h system/array.h \
- system/mem_alloc.h concurrency_control/row__template.h \
- system/mem_alloc.h system/manager.h system/universal.h \
- concurrency_control/_template.h
-obj/catalog.o: storage/catalog.cpp storage/catalog.h system/global.h config.h \
- statistics/stats.h statistics/stats_array.h system/pool.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/txn.h system/array.h system/mem_alloc.h \
+ concurrency_control/row__template.h system/mem_alloc.h \
+ system/manager.h system/universal.h concurrency_control/_template.h
+obj/row_mvcc.o: concurrency_control/row_mvcc.cpp storage/row.h \
+ system/global.h config.h statistics/stats.h statistics/stats_array.h \
+ system/pool.h system/global.h system/universal.h \
+ system/concurrentqueue.h system/txn_table.h system/logMan.h \
+ system/sim_manager.h benchmarks/da_block_queue.h system/txn.h \
+ system/array.h system/mem_alloc.h concurrency_control/row_mvcc.h \
+ system/mem_alloc.h system/manager.h system/universal.h
+obj/_template.o: concurrency_control/_template.cpp system/global.h \
+ config.h statistics/stats.h statistics/stats_array.h system/pool.h \
  system/global.h system/universal.h system/concurrentqueue.h \
  system/txn_table.h system/logMan.h system/sim_manager.h \
- system/universal.h
-obj/index_hash.o: storage/index_hash.cpp system/global.h config.h \
+ benchmarks/da_block_queue.h system/universal.h system/txn.h \
+ system/array.h system/mem_alloc.h concurrency_control/_template.h \
+ storage/row.h system/manager.h system/mem_alloc.h \
+ concurrency_control/row__template.h
+obj/catalog.o: storage/catalog.cpp storage/catalog.h system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/global.h system/universal.h system/concurrentqueue.h \
  system/txn_table.h system/logMan.h system/sim_manager.h \
- storage/IndexHash.h system/universal.h storage/IndexBase.h \
- system/mem_alloc.h storage/row.h
+ benchmarks/da_block_queue.h system/universal.h
 obj/IndexBTree.o: storage/IndexBTree.cpp system/mem_alloc.h system/global.h \
  config.h statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h storage/IndexBTree.h \
- system/global.h system/universal.h storage/IndexBase.h storage/row.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h storage/IndexBTree.h system/universal.h \
+ storage/IndexBase.h storage/row.h
 obj/row.o: storage/row.cpp system/global.h config.h statistics/stats.h \
  statistics/stats_array.h system/pool.h system/global.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h storage/table.h storage/catalog.h \
- system/universal.h storage/row.h system/txn.h system/array.h \
- system/mem_alloc.h concurrency_control/row__template.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ storage/table.h storage/catalog.h system/universal.h storage/row.h \
+ system/txn.h system/array.h system/mem_alloc.h \
+ concurrency_control/row__template.h concurrency_control/row_mvcc.h \
  system/mem_alloc.h system/manager.h
 obj/IndexHash.o: storage/IndexHash.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/global.h system/universal.h system/concurrentqueue.h \
  system/txn_table.h system/logMan.h system/sim_manager.h \
- storage/IndexHash.h system/universal.h storage/IndexBase.h \
- system/mem_alloc.h storage/row.h
+ benchmarks/da_block_queue.h storage/IndexHash.h system/universal.h \
+ storage/IndexBase.h system/mem_alloc.h storage/row.h
 obj/table.o: storage/table.cpp system/global.h config.h statistics/stats.h \
  statistics/stats_array.h system/pool.h system/global.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/universal.h storage/table.h \
- storage/catalog.h storage/row.h system/mem_alloc.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/universal.h storage/table.h storage/catalog.h storage/row.h \
+ system/mem_alloc.h
 obj/message.o: transport/message.cpp system/mem_alloc.h system/global.h \
  config.h statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/query.h system/array.h \
- system/mem_alloc.h benchmarks/qry_ycsb.h system/global.h \
- system/universal.h system/array.h benchmarks/ycsb.h system/workload.h \
- system/txn.h benchmarks/qry_tpcc.h benchmarks/tpcc.h storage/row.h \
- transport/message.h system/logMan.h concurrency_control/_template.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/query.h system/array.h system/mem_alloc.h \
+ benchmarks/qry_ycsb.h system/universal.h system/array.h \
+ benchmarks/ycsb.h system/workload.h system/txn.h benchmarks/qry_tpcc.h \
+ benchmarks/tpcc.h storage/row.h transport/message.h system/logMan.h \
+ concurrency_control/_template.h benchmarks/da.h benchmarks/creator.h \
+ benchmarks/generic.h benchmarks/da_query.h benchmarks/da.h
 obj/msg_thread.o: transport/msg_thread.cpp transport/msg_thread.h \
  system/global.h config.h statistics/stats.h statistics/stats_array.h \
  system/pool.h system/global.h system/universal.h \
  system/concurrentqueue.h system/txn_table.h system/logMan.h \
- system/sim_manager.h system/universal.h transport/nn.hpp \
- system/msg_queue.h system/lock_free_queue.h transport/message.h \
- system/logMan.h system/array.h system/mem_alloc.h system/mem_alloc.h \
- transport/transport.h system/query.h system/array.h \
+ system/sim_manager.h benchmarks/da_block_queue.h system/universal.h \
+ transport/nn.hpp system/msg_queue.h system/lock_free_queue.h \
+ transport/message.h system/logMan.h system/array.h system/mem_alloc.h \
+ system/mem_alloc.h transport/transport.h system/query.h system/array.h \
  benchmarks/qry_ycsb.h benchmarks/qry_tpcc.h system/pool.h
 obj/transport.o: transport/transport.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/global.h system/universal.h system/concurrentqueue.h \
- system/txn_table.h system/logMan.h system/sim_manager.h system/manager.h \
- transport/transport.h transport/nn.hpp system/query.h system/array.h \
- system/mem_alloc.h benchmarks/qry_tpcc.h system/universal.h \
- transport/message.h system/logMan.h system/array.h
+ system/txn_table.h system/logMan.h system/sim_manager.h \
+ benchmarks/da_block_queue.h system/manager.h transport/transport.h \
+ transport/nn.hpp system/query.h system/array.h system/mem_alloc.h \
+ benchmarks/qry_tpcc.h system/universal.h transport/message.h \
+ system/logMan.h system/array.h
 obj/io_thread.o: system/io_thread.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/manager.h system/thread.h \
- system/io_thread.h system/query.h system/array.h system/mem_alloc.h \
- benchmarks/qry_ycsb.h system/global.h system/universal.h system/query.h \
- system/array.h benchmarks/qry_tpcc.h transport/transport.h \
- transport/nn.hpp transport/msg_thread.h system/msg_queue.h \
- system/lock_free_queue.h transport/message.h system/logMan.h \
- client/client_txn.h system/task_queue.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/manager.h system/thread.h system/io_thread.h \
+ system/query.h system/array.h system/mem_alloc.h benchmarks/qry_ycsb.h \
+ system/universal.h system/query.h system/array.h benchmarks/qry_tpcc.h \
+ transport/transport.h transport/nn.hpp transport/msg_thread.h \
+ system/msg_queue.h system/lock_free_queue.h transport/message.h \
+ system/logMan.h client/client_txn.h system/task_queue.h
 obj/manager.o: system/manager.cpp system/manager.h system/universal.h \
  system/global.h config.h statistics/stats.h statistics/stats_array.h \
  system/pool.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h storage/row.h system/global.h \
- system/txn.h system/array.h system/mem_alloc.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h storage/row.h system/txn.h system/array.h \
+ system/mem_alloc.h
 obj/pool.o: system/pool.cpp system/pool.h system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/txn_table.h \
  system/universal.h system/logMan.h system/concurrentqueue.h \
- system/sim_manager.h system/txn.h system/array.h system/mem_alloc.h \
- system/workload.h benchmarks/qry_ycsb.h system/global.h \
- system/universal.h system/query.h system/global.h system/universal.h \
- system/array.h system/array.h benchmarks/ycsb.h system/workload.h \
- system/txn.h benchmarks/qry_tpcc.h system/query.h system/msg_queue.h \
- system/lock_free_queue.h storage/row.h
+ system/sim_manager.h benchmarks/da_block_queue.h system/global.h \
+ system/txn.h system/array.h system/mem_alloc.h system/workload.h \
+ benchmarks/qry_ycsb.h system/universal.h system/query.h system/global.h \
+ system/universal.h system/array.h system/array.h benchmarks/ycsb.h \
+ system/workload.h system/txn.h benchmarks/qry_tpcc.h benchmarks/da.h \
+ storage/row.h benchmarks/creator.h benchmarks/generic.h \
+ benchmarks/da_query.h benchmarks/da.h system/query.h system/msg_queue.h \
+ system/lock_free_queue.h
 obj/thread.o: system/thread.cpp system/global.h config.h statistics/stats.h \
  statistics/stats_array.h system/pool.h system/universal.h \
  system/concurrentqueue.h system/txn_table.h system/logMan.h \
- system/sim_manager.h system/manager.h system/thread.h system/txn.h \
- system/array.h system/mem_alloc.h system/workload.h system/query.h \
- system/msg_queue.h system/lock_free_queue.h transport/message.h \
- system/global.h system/universal.h system/logMan.h system/array.h
+ system/sim_manager.h benchmarks/da_block_queue.h system/global.h \
+ system/manager.h system/thread.h system/txn.h system/array.h \
+ system/mem_alloc.h system/workload.h system/query.h system/msg_queue.h \
+ system/lock_free_queue.h transport/message.h system/universal.h \
+ system/logMan.h system/array.h
+obj/global.o: system/global.cpp system/global.h config.h statistics/stats.h \
+ statistics/stats_array.h system/pool.h system/universal.h \
+ system/concurrentqueue.h system/txn_table.h system/logMan.h \
+ system/sim_manager.h benchmarks/da_block_queue.h system/global.h \
+ system/mem_alloc.h system/manager.h system/query.h system/array.h \
+ client/client_query.h system/universal.h system/query.h \
+ transport/transport.h transport/nn.hpp system/task_queue.h \
+ system/abort_txn_queue.h system/msg_queue.h system/lock_free_queue.h \
+ client/client_txn.h system/sequencer.h \
+ concurrency_control/_template.h storage/row.h
 obj/task_queue.o: system/task_queue.cpp system/task_queue.h system/global.h \
  config.h statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/mem_alloc.h system/query.h \
- system/array.h transport/message.h system/global.h system/universal.h \
- system/logMan.h system/array.h client/client_query.h system/query.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/mem_alloc.h system/query.h system/array.h \
+ transport/message.h system/universal.h system/logMan.h system/array.h \
+ client/client_query.h system/query.h
 obj/sim_manager.o: system/sim_manager.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h
-obj/txn.o: system/txn.cpp system/universal.h system/global.h config.h \
- statistics/stats.h statistics/stats_array.h system/pool.h \
- system/concurrentqueue.h system/txn_table.h system/logMan.h \
- system/sim_manager.h system/txn.h system/array.h system/mem_alloc.h \
- storage/row.h system/global.h system/workload.h system/query.h \
- system/thread.h storage/table.h storage/catalog.h system/universal.h \
- storage/IndexBTree.h storage/IndexBase.h storage/IndexHash.h \
- system/msg_queue.h system/lock_free_queue.h transport/message.h \
- system/logMan.h system/array.h benchmarks/qry_ycsb.h system/query.h \
- benchmarks/qry_tpcc.h concurrency_control/_template.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h
 obj/msg_queue.o: system/msg_queue.cpp system/msg_queue.h system/global.h \
  config.h statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/lock_free_queue.h \
- system/mem_alloc.h system/query.h system/array.h transport/message.h \
- system/global.h system/universal.h system/logMan.h system/array.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/lock_free_queue.h system/mem_alloc.h \
+ system/query.h system/array.h transport/message.h system/universal.h \
+ system/logMan.h system/array.h
 obj/log_thread.o: system/log_thread.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/thread.h system/log_thread.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/thread.h system/log_thread.h
 obj/logMan.o: system/logMan.cpp system/logMan.h system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/sim_manager.h system/task_queue.h transport/message.h \
- system/global.h system/universal.h system/logMan.h system/array.h \
- system/global.h system/universal.h system/mem_alloc.h system/mem_alloc.h
-obj/calvin_txn_thread.o: system/calvin_txn_thread.cpp system/global.h \
- config.h statistics/stats.h statistics/stats_array.h system/pool.h \
- system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/manager.h system/thread.h \
- system/calvin_txn_thread.h system/txn.h system/array.h \
- system/mem_alloc.h system/workload.h system/query.h \
- benchmarks/qry_ycsb.h system/global.h system/universal.h system/query.h \
- system/array.h benchmarks/qry_tpcc.h transport/transport.h \
- transport/nn.hpp transport/msg_thread.h system/msg_queue.h \
- system/lock_free_queue.h system/sequencer.h transport/message.h \
- system/logMan.h system/task_queue.h
+ system/sim_manager.h benchmarks/da_block_queue.h system/global.h \
+ system/task_queue.h transport/message.h system/universal.h \
+ system/logMan.h system/array.h system/global.h system/universal.h \
+ system/mem_alloc.h system/mem_alloc.h
 obj/abort_txn_queue.o: system/abort_txn_queue.cpp system/mem_alloc.h \
  system/global.h config.h statistics/stats.h statistics/stats_array.h \
  system/pool.h system/universal.h system/concurrentqueue.h \
  system/txn_table.h system/logMan.h system/sim_manager.h \
- system/abort_txn_queue.h transport/message.h system/global.h \
- system/universal.h system/logMan.h system/array.h system/global.h \
- system/universal.h system/mem_alloc.h system/task_queue.h
+ benchmarks/da_block_queue.h system/global.h system/abort_txn_queue.h \
+ transport/message.h system/universal.h system/logMan.h system/array.h \
+ system/global.h system/universal.h system/mem_alloc.h \
+ system/task_queue.h
 obj/universal.o: system/universal.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/mem_alloc.h
-obj/global.o: system/global.cpp system/global.h config.h statistics/stats.h \
- statistics/stats_array.h system/pool.h system/universal.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/mem_alloc.h
+obj/txn.o: system/txn.cpp system/universal.h system/global.h config.h \
+ statistics/stats.h statistics/stats_array.h system/pool.h \
  system/concurrentqueue.h system/txn_table.h system/logMan.h \
- system/sim_manager.h system/mem_alloc.h system/manager.h system/query.h \
- system/array.h client/client_query.h system/global.h system/universal.h \
- system/query.h transport/transport.h transport/nn.hpp \
- system/task_queue.h system/abort_txn_queue.h system/msg_queue.h \
- system/lock_free_queue.h client/client_txn.h system/sequencer.h \
- concurrency_control/_template.h storage/row.h
+ system/sim_manager.h benchmarks/da_block_queue.h system/global.h \
+ system/txn.h system/array.h system/mem_alloc.h storage/row.h \
+ system/workload.h system/query.h system/thread.h storage/table.h \
+ storage/catalog.h system/universal.h storage/IndexBTree.h \
+ storage/IndexBase.h storage/IndexHash.h system/msg_queue.h \
+ system/lock_free_queue.h transport/message.h system/logMan.h \
+ system/array.h benchmarks/qry_ycsb.h system/query.h \
+ benchmarks/qry_tpcc.h concurrency_control/_template.h
 obj/abort_txn_thread.o: system/abort_txn_thread.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/thread.h \
- system/abort_txn_thread.h system/abort_txn_queue.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/thread.h system/abort_txn_thread.h \
+ system/abort_txn_queue.h
 obj/client_thread.o: system/client_thread.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/thread.h \
- system/client_thread.h system/query.h system/array.h system/mem_alloc.h \
- benchmarks/qry_ycsb.h system/global.h system/universal.h system/query.h \
- system/array.h benchmarks/qry_tpcc.h client/client_query.h \
- transport/transport.h transport/nn.hpp client/client_txn.h \
- transport/msg_thread.h system/msg_queue.h system/lock_free_queue.h \
- system/workload.h transport/message.h system/logMan.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/thread.h system/client_thread.h system/query.h \
+ system/array.h system/mem_alloc.h benchmarks/qry_ycsb.h \
+ system/universal.h system/query.h system/array.h benchmarks/qry_tpcc.h \
+ client/client_query.h transport/transport.h transport/nn.hpp \
+ client/client_txn.h transport/msg_thread.h system/msg_queue.h \
+ system/lock_free_queue.h system/workload.h transport/message.h \
+ system/logMan.h
+obj/task_thread.o: system/task_thread.cpp system/global.h config.h \
+ statistics/stats.h statistics/stats_array.h system/pool.h \
+ system/universal.h system/concurrentqueue.h system/txn_table.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/manager.h system/thread.h system/task_thread.h \
+ system/txn.h system/array.h system/mem_alloc.h system/workload.h \
+ system/query.h benchmarks/qry_ycsb.h system/universal.h system/query.h \
+ system/array.h benchmarks/qry_tpcc.h benchmarks/test.h system/workload.h \
+ system/txn.h transport/msg_thread.h transport/nn.hpp system/msg_queue.h \
+ system/lock_free_queue.h system/task_queue.h transport/message.h \
+ system/logMan.h system/abort_txn_queue.h \
+ concurrency_control/_template.h storage/row.h
 obj/lock_free_queue.o: system/lock_free_queue.cpp system/universal.h \
  system/global.h config.h statistics/stats.h statistics/stats_array.h \
  system/pool.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/lock_free_queue.h
-obj/worker_thread.o: system/worker_thread.cpp system/global.h config.h \
- statistics/stats.h statistics/stats_array.h system/pool.h \
- system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/manager.h system/thread.h \
- system/worker_thread.h system/txn.h system/array.h system/mem_alloc.h \
- system/workload.h system/query.h benchmarks/qry_ycsb.h system/global.h \
- system/universal.h system/query.h system/array.h benchmarks/qry_tpcc.h \
- benchmarks/test.h system/workload.h system/txn.h transport/msg_thread.h \
- transport/nn.hpp system/msg_queue.h system/lock_free_queue.h \
- system/task_queue.h transport/message.h system/logMan.h \
- system/abort_txn_queue.h concurrency_control/_template.h \
- storage/row.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/lock_free_queue.h
 obj/parser.o: system/parser.cpp system/global.h config.h statistics/stats.h \
  statistics/stats_array.h system/pool.h system/universal.h \
  system/concurrentqueue.h system/txn_table.h system/logMan.h \
- system/sim_manager.h
+ system/sim_manager.h benchmarks/da_block_queue.h system/global.h
 obj/workload.o: system/workload.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/workload.h storage/row.h \
- system/global.h storage/table.h storage/IndexHash.h system/universal.h \
- storage/IndexBase.h storage/IndexBTree.h storage/catalog.h \
- system/mem_alloc.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/workload.h storage/row.h storage/table.h \
+ storage/IndexHash.h system/universal.h storage/IndexBase.h \
+ storage/IndexBTree.h storage/catalog.h system/mem_alloc.h
+obj/calvin_txn_thread.o: system/calvin_txn_thread.cpp system/global.h \
+ config.h statistics/stats.h statistics/stats_array.h system/pool.h \
+ system/universal.h system/concurrentqueue.h system/txn_table.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/manager.h system/thread.h \
+ system/calvin_txn_thread.h system/txn.h system/array.h \
+ system/mem_alloc.h system/workload.h system/query.h \
+ benchmarks/qry_ycsb.h system/universal.h system/query.h system/array.h \
+ benchmarks/qry_tpcc.h transport/transport.h transport/nn.hpp \
+ transport/msg_thread.h system/msg_queue.h system/lock_free_queue.h \
+ system/sequencer.h transport/message.h system/logMan.h \
+ system/task_queue.h
 obj/txn_table.o: system/txn_table.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h benchmarks/qry_tpcc.h \
- system/global.h system/universal.h system/query.h system/global.h \
- system/universal.h system/array.h system/mem_alloc.h benchmarks/tpcc.h \
- system/workload.h system/txn.h storage/row.h benchmarks/qry_ycsb.h \
- system/array.h benchmarks/ycsb.h system/query.h system/txn.h \
- system/mem_alloc.h system/task_queue.h transport/message.h \
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h benchmarks/qry_tpcc.h system/universal.h system/query.h \
+ system/global.h system/universal.h system/array.h system/mem_alloc.h \
+ benchmarks/tpcc.h system/workload.h system/txn.h storage/row.h \
+ benchmarks/qry_ycsb.h system/array.h benchmarks/ycsb.h system/query.h \
+ system/txn.h system/mem_alloc.h system/task_queue.h transport/message.h \
  system/logMan.h
 obj/main.o: system/main.cpp system/global.h config.h statistics/stats.h \
  statistics/stats_array.h system/pool.h system/universal.h \
  system/concurrentqueue.h system/txn_table.h system/logMan.h \
- system/sim_manager.h benchmarks/ycsb.h system/workload.h system/global.h \
- system/txn.h system/universal.h system/array.h system/mem_alloc.h \
- system/global.h system/universal.h benchmarks/tpcc.h system/query.h \
- storage/row.h benchmarks/test.h system/thread.h system/worker_thread.h \
- system/calvin_txn_thread.h system/abort_txn_thread.h system/io_thread.h \
- system/log_thread.h system/manager.h system/query.h \
- transport/transport.h transport/nn.hpp system/msg_queue.h \
- system/lock_free_queue.h benchmarks/qry_ycsb.h system/array.h \
- system/sequencer.h system/abort_txn_queue.h system/task_queue.h \
- concurrency_control/_template.h client/client_query.h
+ system/sim_manager.h benchmarks/da_block_queue.h system/global.h \
+ benchmarks/ycsb.h system/workload.h system/global.h system/txn.h \
+ system/universal.h system/array.h system/mem_alloc.h system/universal.h \
+ benchmarks/tpcc.h system/query.h storage/row.h benchmarks/test.h \
+ system/thread.h system/task_thread.h system/calvin_txn_thread.h \
+ system/abort_txn_thread.h system/io_thread.h system/log_thread.h \
+ system/manager.h system/query.h transport/transport.h transport/nn.hpp \
+ system/msg_queue.h system/lock_free_queue.h benchmarks/qry_ycsb.h \
+ system/array.h system/sequencer.h system/abort_txn_queue.h \
+ system/task_queue.h concurrency_control/_template.h \
+ client/client_query.h benchmarks/da.h benchmarks/creator.h \
+ benchmarks/generic.h
 obj/mem_alloc.o: system/mem_alloc.cpp system/mem_alloc.h system/global.h \
  config.h statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h jemalloc/jemalloc.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h jemalloc/jemalloc.h
 obj/query.o: system/query.cpp system/query.h system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/array.h system/mem_alloc.h \
- system/workload.h storage/table.h system/global.h benchmarks/qry_ycsb.h \
- system/universal.h system/query.h system/array.h benchmarks/qry_tpcc.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/array.h system/mem_alloc.h system/workload.h \
+ storage/table.h benchmarks/qry_ycsb.h system/universal.h system/query.h \
+ system/array.h benchmarks/qry_tpcc.h benchmarks/da_query.h \
+ benchmarks/da.h storage/row.h system/txn.h system/global.h \
+ system/universal.h system/array.h system/workload.h benchmarks/creator.h \
+ benchmarks/generic.h
 obj/sequencer.o: system/sequencer.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/sequencer.h system/query.h \
- system/array.h system/mem_alloc.h benchmarks/qry_ycsb.h system/global.h \
- system/universal.h system/query.h system/array.h benchmarks/qry_tpcc.h \
- transport/transport.h transport/nn.hpp system/workload.h \
- system/msg_queue.h system/lock_free_queue.h transport/msg_thread.h \
- system/task_queue.h transport/message.h system/logMan.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/global.h system/sequencer.h system/query.h system/array.h \
+ system/mem_alloc.h benchmarks/qry_ycsb.h system/universal.h \
+ system/query.h system/array.h benchmarks/qry_tpcc.h \
+ benchmarks/da_query.h benchmarks/da.h storage/row.h system/txn.h \
+ system/global.h system/universal.h system/array.h system/workload.h \
+ benchmarks/creator.h benchmarks/generic.h transport/transport.h \
+ transport/nn.hpp system/workload.h system/msg_queue.h \
+ system/lock_free_queue.h transport/msg_thread.h system/task_queue.h \
+ transport/message.h system/logMan.h
 obj/stats.o: statistics/stats.cpp system/global.h config.h statistics/stats.h \
  statistics/stats_array.h system/pool.h system/global.h \
  system/universal.h system/concurrentqueue.h system/txn_table.h \
- system/logMan.h system/sim_manager.h system/universal.h \
- statistics/stats.h system/mem_alloc.h client/client_txn.h \
- system/task_queue.h statistics/stats_array.h
+ system/logMan.h system/sim_manager.h benchmarks/da_block_queue.h \
+ system/universal.h statistics/stats.h system/mem_alloc.h \
+ client/client_txn.h system/task_queue.h statistics/stats_array.h
 obj/stats_array.o: statistics/stats_array.cpp system/global.h config.h \
  statistics/stats.h statistics/stats_array.h system/pool.h \
  system/global.h system/universal.h system/concurrentqueue.h \
  system/txn_table.h system/logMan.h system/sim_manager.h \
- system/universal.h statistics/stats.h system/mem_alloc.h \
- client/client_txn.h system/task_queue.h
+ benchmarks/da_block_queue.h system/universal.h statistics/stats.h \
+ system/mem_alloc.h client/client_txn.h system/task_queue.h
diff --git a/statistics/stats.cpp b/statistics/stats.cpp
index ce7771b..0afa94c 100644
--- a/statistics/stats.cpp
+++ b/statistics/stats.cpp
@@ -46,6 +46,7 @@ void Stats_thd::clear() {
   local_txn_commit_cnt=0;
   remote_txn_commit_cnt=0;
   total_txn_abort_cnt=0;
+  positive_txn_abort_cnt=0;
   unique_txn_abort_cnt=0;
   local_txn_abort_cnt=0;
   remote_txn_abort_cnt=0;
@@ -425,6 +426,7 @@ void Stats_thd::print(FILE * outf, bool prog) {
   ",local_txn_commit_cnt=%ld"
   ",remote_txn_commit_cnt=%ld"
   ",total_txn_abort_cnt=%ld"
+  ",positive_txn_abort_cnt=%ld"
   ",unique_txn_abort_cnt=%ld"
   ",local_txn_abort_cnt=%ld"
   ",remote_txn_abort_cnt=%ld"
@@ -449,6 +451,7 @@ void Stats_thd::print(FILE * outf, bool prog) {
   ,local_txn_commit_cnt
   ,remote_txn_commit_cnt
   ,total_txn_abort_cnt
+  ,positive_txn_abort_cnt
   ,unique_txn_abort_cnt
   ,local_txn_abort_cnt
   ,remote_txn_abort_cnt
@@ -1150,6 +1153,7 @@ void Stats_thd::combine(Stats_thd * stats) {
   local_txn_commit_cnt+=stats->local_txn_commit_cnt;
   remote_txn_commit_cnt+=stats->remote_txn_commit_cnt;
   total_txn_abort_cnt+=stats->total_txn_abort_cnt;
+  positive_txn_abort_cnt+=stats->positive_txn_abort_cnt;
   unique_txn_abort_cnt+=stats->unique_txn_abort_cnt;
   local_txn_abort_cnt+=stats->local_txn_abort_cnt;
   remote_txn_abort_cnt+=stats->remote_txn_abort_cnt;
diff --git a/statistics/stats.h b/statistics/stats.h
index 63baedc..c1ec9fb 100644
--- a/statistics/stats.h
+++ b/statistics/stats.h
@@ -43,6 +43,7 @@ public:
   uint64_t local_txn_commit_cnt;
   uint64_t remote_txn_commit_cnt;
   uint64_t total_txn_abort_cnt;
+  uint64_t positive_txn_abort_cnt;
   uint64_t unique_txn_abort_cnt;
   uint64_t local_txn_abort_cnt;
   uint64_t remote_txn_abort_cnt;
diff --git a/storage/IndexBTree.cpp b/storage/IndexBTree.cpp
index cb25121..2c0e727 100644
--- a/storage/IndexBTree.cpp
+++ b/storage/IndexBTree.cpp
@@ -388,8 +388,9 @@ RC IndexBTree::insert_into_leaf(glob_param params, bt_node * leaf, idx_key_t key
 		leaf->pointers[idx] = (void *) item;
 		return RCOK;
 	}
-    while (insertion_point < leaf->num_keys && leaf->keys[insertion_point] < key)
+    while (insertion_point < leaf->num_keys && leaf->keys[insertion_point] < key) {
         insertion_point++;
+	}
 	for (i = leaf->num_keys; i > insertion_point; i--) {
         leaf->keys[i] = leaf->keys[i - 1];
         leaf->pointers[i] = leaf->pointers[i - 1];
@@ -484,8 +485,9 @@ RC IndexBTree::insert_into_parent(
     bt_node * parent = left->parent;
 
     /* Case: new root. */
-    if (parent == NULL)
+    if (parent == NULL) {
         return insert_into_new_root(params, left, key, right);
+	}
     
 	UInt32 insert_idx = 0;
 	while (parent->keys[insert_idx] < key && insert_idx < parent->num_keys)
diff --git a/storage/IndexHash.cpp b/storage/IndexHash.cpp
index e1d403d..4f753c5 100644
--- a/storage/IndexHash.cpp
+++ b/storage/IndexHash.cpp
@@ -33,6 +33,12 @@ void IndexHash::delete_this_index() {
   delete _buckets;
 }
 
+void IndexHash::index_reset() {
+  for (UInt32 n = 0; n < _bucket_cnt_per_part; n ++) {
+			_buckets[0][n].delete_bucket();
+  }
+}
+
 bool IndexHash::index_is_exist(idx_key_t key) {
 	assert(false);
 }
diff --git a/storage/IndexHash.h b/storage/IndexHash.h
index d1497e8..df88fe6 100644
--- a/storage/IndexHash.h
+++ b/storage/IndexHash.h
@@ -46,7 +46,8 @@ public:
 	RC 			init(int part_cnt, 
 					TableSchema * table, 
 					uint64_t bucket_cnt);
-  void    delete_this_index();
+	void    	delete_this_index();
+	void 		index_reset();
 	bool 		index_is_exist(idx_key_t key); // check if the key exist.
 	RC 			index_insert(idx_key_t key, itemidData * item, int part_id=-1);
 	RC 			index_insert_non_unique(idx_key_t key, itemidData * item, int part_id=-1);
diff --git a/storage/row.cpp b/storage/row.cpp
index 7437a8d..2edc378 100644
--- a/storage/row.cpp
+++ b/storage/row.cpp
@@ -5,6 +5,7 @@
 #include "row.h"
 #include "txn.h"
 #include "row__template.h"
+#include "row_mvcc.h"
 #include "mem_alloc.h"
 #include "manager.h"
 
@@ -189,6 +190,15 @@ RC RowData::get_row(access_t type, TxnMgr * txn, RowData *& row) {
     assert(rc == RCOK);
 	goto end;
 #endif
+#if ALGO == MVCC
+    DEBUG_M("RowData::get_row MVCC alloc \n");
+	txn->cur_row = (RowData *) alloc_memory.alloc(sizeof(RowData));
+	txn->cur_row->init(get_table(), get_part_id());
+    rc = this->manager->access(type,txn,txn->cur_row);
+	row = txn->cur_row;
+    assert(rc == RCOK);
+	goto end;
+#endif
 #if ALGO == HSTORE || ALGO == HSTORE_SPEC || ALGO == CALVIN
 #if ALGO == HSTORE_SPEC
   if(txn_table.spec_mode) {
@@ -247,14 +257,25 @@ void RowData::return_row(RC rc, access_t type, TxnMgr * txn, RowData * row) {
 	this->manager->lock_release(txn);
 #elif ALGO == TEMPLATE 
 	assert (row != NULL);
-  if (rc == Abort) {
-    manager->abort(type,txn);
-  } else {
-    manager->commit(type,txn,row);
-  }
+	if (rc == Abort) {
+		manager->abort(type,txn);
+	} else {
+		manager->commit(type,txn,row);
+	}
+
+	row->free_row();
+  	DEBUG_M("RowData::return_row _template free \n");
+	alloc_memory.free(row, sizeof(RowData));
+#elif ALGO == MVCC 
+	assert (row != NULL);
+	if (rc == Abort) {
+		manager->abort(type,txn);
+	} else {
+		manager->commit(type,txn,row);
+	}
 
 	row->free_row();
-  DEBUG_M("RowData::return_row _template free \n");
+  	DEBUG_M("RowData::return_row _template free \n");
 	alloc_memory.free(row, sizeof(RowData));
 #elif ALGO == HSTORE || ALGO == HSTORE_SPEC 
 	assert (row != NULL);
diff --git a/storage/row.h b/storage/row.h
index 8bf2ab8..6cd9e50 100644
--- a/storage/row.h
+++ b/storage/row.h
@@ -33,6 +33,7 @@ class TableSchema;
 class CatalogSchema;
 class TxnMgr;
 class Row__template;
+class Row_mvcc;
 class Row_specex;
 
 class RowData
@@ -89,6 +90,8 @@ public:
 
   #if ALGO == TEMPLATE 
   	Row__template * manager;
+  #elif ALGO == MVCC
+  	Row_mvcc * manager;
   #elif ALGO == HSTORE_SPEC
   	Row_specex * manager;
   #elif ALGO == AVOID
diff --git a/system/client_thread.cpp b/system/client_thread.cpp
index 0463cc0..39651ea 100644
--- a/system/client_thread.cpp
+++ b/system/client_thread.cpp
@@ -15,7 +15,7 @@
 
 void ClientThread::setup() {
 	if( _thd_id == 0) {
-    send_init_done_to_nodes();
+	send_init_done_to_nodes();
   }
 #if LOAD_METHOD == LOAD_RATE
   assert(g_per_server_load > 0);
@@ -53,14 +53,16 @@ RC ClientThread::run() {
 		if (iters == UINT64_MAX)
 			iters = 0;
 #if LOAD_METHOD == LOAD_MAX
+#if WORKLOAD != DA
 		if ((inf_cnt = client_man.inc_inflight(next_node)) < 0)
 			continue;
-
+#endif
 		m_query = qry_queue_client.get_next_query(next_node,_thd_id);
     if(last_send_time > 0) {
       INC_STATS(read_thd_id(),cl_send_intv,acquire_ts() - last_send_time);
     }
     last_send_time = acquire_ts();
+    simulate_man->last_da_query_time = acquire_ts();
 #elif LOAD_METHOD == LOAD_RATE
 		if ((inf_cnt = client_man.inc_inflight(next_node)) < 0)
 			continue;
@@ -85,7 +87,9 @@ RC ClientThread::run() {
 		num_txns_sent++;
 		txns_sent[next_node]++;
     INC_STATS(read_thd_id(),txn_sent_cnt,1);
-
+		#if WORKLOAD==DA
+			delete m_query;
+		#endif
 	}
 
 
diff --git a/system/global.cpp b/system/global.cpp
index e6973b8..739f025 100644
--- a/system/global.cpp
+++ b/system/global.cpp
@@ -43,6 +43,18 @@ Sequencer seq_man;
 LogMan logger;
 TimestampBounds txn_timestamp_bounds;
 
+boost::lockfree::queue<DAQuery*, boost::lockfree::fixed_sized<true>> da_query_queue{100};
+DABlockQueue da_gen_qry_queue(50);
+bool is_server=false;
+map<uint64_t, ts_t> da_start_stamp_tab;
+set<uint64_t> da_start_trans_tab;
+map<uint64_t, ts_t> da_stamp_tab;
+set<uint64_t> already_abort_tab;
+string DA_history_mem;
+bool abort_history;
+ofstream commit_file;
+ofstream abort_file;
+
 bool volatile warmup_done = false;
 bool volatile enable_thread_mem_pool = false;
 pthread_barrier_t warmup_bar;
diff --git a/system/global.h b/system/global.h
index 736c6c7..ad8ea1c 100644
--- a/system/global.h
+++ b/system/global.h
@@ -33,7 +33,8 @@
 #include "logMan.h"
 #include "sim_manager.h"
 //#include "_template.h"
-
+#include <boost/lockfree/queue.hpp>
+#include "da_block_queue.h"
 using namespace std;
 
 class mem_alloc;
@@ -61,6 +62,8 @@ class Client_txn;
 class Sequencer;
 class LogMan;
 class TimestampBounds;
+class DAQuery;
+class DABlockQueue;
 
 typedef uint32_t UInt32;
 typedef int32_t SInt32;
@@ -192,6 +195,18 @@ extern UInt32 g_dist_per_wh;
 extern UInt32 g_cust_per_dist;
 extern UInt32 g_max_items_per_txn;
 
+extern boost::lockfree::queue<DAQuery*, boost::lockfree::fixed_sized<true>> da_query_queue;
+extern DABlockQueue da_gen_qry_queue;
+extern bool is_server;
+extern map<uint64_t, ts_t> da_start_stamp_tab;
+extern set<uint64_t> da_start_trans_tab;
+extern map<uint64_t, ts_t> da_stamp_tab;
+extern set<uint64_t> already_abort_tab;
+extern string DA_history_mem;
+extern bool abort_history;
+extern ofstream commit_file;
+extern ofstream abort_file;
+
 // CALVIN
 extern UInt32 g_seq_thread_cnt;
 
diff --git a/system/main.cpp b/system/main.cpp
index b594910..c3ff3ba 100644
--- a/system/main.cpp
+++ b/system/main.cpp
@@ -23,7 +23,7 @@
 #include "task_queue.h"
 #include "_template.h"
 #include "client_query.h"
-
+#include "da.h"
 void network_test();
 void network_recv();
 void * work_thread(void *);
@@ -56,41 +56,45 @@ int main(int argc, char* argv[])
 
 	int64_t begintime;
 	int64_t endtime;
-  int64_t exectime;
-  begintime = get_serverdb_clock();
-  printf("Initializing stats... ");
-  fflush(stdout);
+	int64_t exectime;
+	begintime = get_serverdb_clock();
+	printf("Initializing stats... ");
+	fflush(stdout);
 	stats.init(g_thread_total_cnt);
-  printf("Done\n");
-  printf("Initializing glob manager... "); //global manager
-  fflush(stdout);
+	printf("Done\n");
+	printf("Initializing glob manager... "); //global manager
+	fflush(stdout);
 	global_manager.init();
-  printf("Done\n");
-  printf("Initializing tport manager... "); //transport manager
-  fflush(stdout);
+	printf("Done\n");
+	printf("Initializing tport manager... "); //transport manager
+	fflush(stdout);
 	tport_manager.init();
-  printf("Done\n");
-  fflush(stdout);
-  printf("Initializing simulate_man... ");
-  fflush(stdout);
-  simulate_man = new Simulator;
-  simulate_man->init();
-  printf("Done\n");
-  fflush(stdout);
+	printf("Done\n");
+	fflush(stdout);
+	printf("Initializing simulate_man... ");
+	fflush(stdout);
+	simulate_man = new Simulator;
+	simulate_man->init();
+	printf("Done\n");
+	fflush(stdout);
 	WLSchema * m_workload;
 	switch (WORKLOAD) {
 		case YCSB :
 			m_workload = new WLYCSB; break;
 		case TPCC :
 			m_workload = new WLTPCC; break;
-    case TEST :
+	case TEST :
 			m_workload = new WLCTEST; break;
+		case DA:
+			m_workload = new DAWorkload;
+			is_server=true;
+			break;
 		default:
 			assert(false);
 	}
 	m_workload->init();
 	printf("WLSchema initialized!\n");
-  fflush(stdout);
+  	fflush(stdout);
 #if NETWORK_TEST
 	tport_manager.init(g_node_id,m_workload);
 	sleep(3);
@@ -101,56 +105,56 @@ int main(int argc, char* argv[])
 
 	return 0;
 #endif
-  fflush(stdout);
-  task_queue.init();
-  printf("Task queue Initialized... ");
-  abort_queue.init();
-  printf("Abort txn queue Initialized... ");
-  fflush(stdout);
-  msg_queue.init();
-  printf("Msg queue Initialized... ");
-  fflush(stdout);
-  txn_man_pool.init(m_workload,0);
-  printf("Txn manager pool Initialized... ");
-  fflush(stdout);
-  txn_pool.init(m_workload,0);
-  printf("Txn pool Initialized... ");
-  fflush(stdout);
-  row_pool.init(m_workload,0);
-  printf("Row pool Initialized... ");
-  fflush(stdout);
-  acc_pool.init(m_workload,0);
-  printf("Access pool Initialized... ");
-  fflush(stdout);
-  tbl_txn_pool.init(m_workload,0);
-  printf("Txn node table pool Initialized... ");
-  fflush(stdout);
-  query_pool.init(m_workload,0);
-  printf("Query pool Initialized... ");
-  fflush(stdout);
-  message_pool.init(m_workload,0);
-  printf("Msg pool Initialized... ");
-  fflush(stdout);
-  txn_table.init();
-  printf("Txn table Initialized... ");
-  fflush(stdout);
+	fflush(stdout);
+	task_queue.init();
+	printf("Task queue Initialized... ");
+	abort_queue.init();
+	printf("Abort txn queue Initialized... ");
+	fflush(stdout);
+	msg_queue.init();
+	printf("Msg queue Initialized... ");
+	fflush(stdout);
+	txn_man_pool.init(m_workload,0);
+	printf("Txn manager pool Initialized... ");
+	fflush(stdout);
+	txn_pool.init(m_workload,0);
+	printf("Txn pool Initialized... ");
+	fflush(stdout);
+	row_pool.init(m_workload,0);
+	printf("Row pool Initialized... ");
+	fflush(stdout);
+	acc_pool.init(m_workload,0);
+	printf("Access pool Initialized... ");
+	fflush(stdout);
+	tbl_txn_pool.init(m_workload,0);
+	printf("Txn node table pool Initialized... ");
+	fflush(stdout);
+	query_pool.init(m_workload,0);
+	printf("Query pool Initialized... ");
+	fflush(stdout);
+	message_pool.init(m_workload,0);
+	printf("Msg pool Initialized... ");
+	fflush(stdout);
+	txn_table.init();
+	printf("Txn table Initialized... ");
+	fflush(stdout);
 #if ALGO == CALVIN
-  seq_man.init(m_workload);
-  printf("Sequencer Initialized... ");
-  fflush(stdout);
+	seq_man.init(m_workload);
+	printf("Sequencer Initialized... ");
+	fflush(stdout);
 #endif
 #if ALGO == TEMPLATE
-  txn_timestamp_bounds.init();
-  printf("Time Table Initialized... ");
-  fflush(stdout);
+  	txn_timestamp_bounds.init();
+	printf("Time Table Initialized... ");
+	fflush(stdout);
 	_template_man.init();
-  printf(" template manager Initialized... ");
-  fflush(stdout);
+	printf(" template manager Initialized... ");
+	fflush(stdout);
 #endif
 #if LOGGING
-  logger.init("logfile.log");
-  printf("Log manager Initialized... ");
-  fflush(stdout);
+	logger.init("logfile.log");
+	printf("Log manager Initialized... ");
+	fflush(stdout);
 #endif
 
 #if SERVER_GENERATE_QUERIES
@@ -159,103 +163,107 @@ int main(int argc, char* argv[])
   fflush(stdout);
 #endif
 
+#if WORKLOAD==DA
+	commit_file.open("commit_histroy.txt",ios::app);
+	abort_file.open("abort_histroy.txt",ios::app);
+#endif
+
 	// 2. spawn multiple threads
 	uint64_t thd_cnt = g_thd_cnt;
 	uint64_t w_thd_cnt = thd_cnt;
 	uint64_t r_thd_cnt = g_rem_thd_cnt;
 	uint64_t s_thd_cnt = g_send_thd_cnt;
-  uint64_t thd_cnt_all = thd_cnt + r_thd_cnt + s_thd_cnt + g_abort_thread_cnt;
+  	uint64_t thd_cnt_all = thd_cnt + r_thd_cnt + s_thd_cnt + g_abort_thread_cnt;
 #if LOGGING
-  thd_cnt_all += 1; // logger thread
+  	thd_cnt_all += 1; // logger thread
 #endif
 #if ALGO == CALVIN
-  thd_cnt_all += 2; // sequencer + scheduler thread
+  	thd_cnt_all += 2; // sequencer + scheduler thread
 #endif
-    assert(thd_cnt_all == g_this_total_thread_cnt);
+	assert(thd_cnt_all == g_this_total_thread_cnt);
 	
-    pthread_t * p_threads =
-    (pthread_t *) malloc(sizeof(pthread_t) * (thd_cnt_all));
-    pthread_attr_t attrib;
-    pthread_attr_init(&attrib);
+	pthread_t * p_threads =
+	(pthread_t *) malloc(sizeof(pthread_t) * (thd_cnt_all));
+	pthread_attr_t attrib;
+	pthread_attr_init(&attrib);
 
-    work_thds = new TaskThread[w_thd_cnt];
-    input_thds = new InputThread[r_thd_cnt];
-    output_thds = new OutputThread[s_thd_cnt];
-    abort_thds = new AbortTxnThread[1];
-    logger_thds = new LogThread[1];
+	work_thds = new TaskThread[w_thd_cnt];
+	input_thds = new InputThread[r_thd_cnt];
+	output_thds = new OutputThread[s_thd_cnt];
+	abort_thds = new AbortTxnThread[1];
+	logger_thds = new LogThread[1];
 #if ALGO == CALVIN
-    calvin_sched_thds = new CalvinscheduleThread[1];
-    calvin_seq_thds = new CalvinSequenceThread[1];
+	calvin_sched_thds = new CalvinscheduleThread[1];
+	calvin_seq_thds = new CalvinSequenceThread[1];
 #endif
 
-    endtime = get_serverdb_clock();
-    exectime = endtime - begintime;
-    printf("Initialization Time = %ld\n", exectime);
-    fflush(stdout);
-    warmup_done = true;
-    pthread_barrier_init( &warmup_bar, NULL, thd_cnt_all);
+	endtime = get_serverdb_clock();
+	exectime = endtime - begintime;
+	printf("Initialization Time = %ld\n", exectime);
+	fflush(stdout);
+	warmup_done = true;
+	pthread_barrier_init( &warmup_bar, NULL, thd_cnt_all);
 
 #if SET_AFFINITY
-  uint64_t cpus_cnt = 0;
-  cpu_set_t cpus;
+	uint64_t cpus_cnt = 0;
+	cpu_set_t cpus;
 #endif
-  // spawn and run txns again.
-  begintime = get_serverdb_clock();
-  simulate_man->run_begintime = begintime;
-
-  uint64_t id = 0;
-  for (uint64_t i = 0; i < w_thd_cnt; i++) {
+	// spawn and run txns again.
+	begintime = get_serverdb_clock();
+	simulate_man->run_begintime = begintime;
+	simulate_man->last_da_query_time = begintime;
+	uint64_t id = 0;
+	for (uint64_t i = 0; i < w_thd_cnt; i++) {
 #if SET_AFFINITY
-      CPU_ZERO(&cpus);
-      CPU_SET(cpus_cnt, &cpus);
-      pthread_attr_setaffinity_np(&attrib, sizeof(cpu_set_t), &cpus);
-      cpus_cnt++;
+		CPU_ZERO(&cpus);
+		CPU_SET(cpus_cnt, &cpus);
+		pthread_attr_setaffinity_np(&attrib, sizeof(cpu_set_t), &cpus);
+		cpus_cnt++;
 #endif
-      assert(id >= 0 && id < w_thd_cnt);
-      work_thds[i].init(id,g_node_id,m_workload);
-      pthread_create(&p_threads[id++], &attrib, work_thread, (void *)&work_thds[i]);
+		assert(id >= 0 && id < w_thd_cnt);
+		work_thds[i].init(id,g_node_id,m_workload);
+		pthread_create(&p_threads[id++], &attrib, work_thread, (void *)&work_thds[i]);
 	}
 	for (uint64_t j = 0; j < r_thd_cnt ; j++) {
-	    assert(id >= w_thd_cnt && id < w_thd_cnt + r_thd_cnt);
-	    input_thds[j].init(id,g_node_id,m_workload);
-	    pthread_create(&p_threads[id++], NULL, work_thread, (void *)&input_thds[j]);
+		assert(id >= w_thd_cnt && id < w_thd_cnt + r_thd_cnt);
+		input_thds[j].init(id,g_node_id,m_workload);
+		pthread_create(&p_threads[id++], NULL, work_thread, (void *)&input_thds[j]);
 	}
 
 
 	for (uint64_t j = 0; j < s_thd_cnt; j++) {
-	    assert(id >= w_thd_cnt + r_thd_cnt && id < w_thd_cnt + r_thd_cnt + s_thd_cnt);
-	    output_thds[j].init(id,g_node_id,m_workload);
-	    pthread_create(&p_threads[id++], NULL, work_thread, (void *)&output_thds[j]);
+		assert(id >= w_thd_cnt + r_thd_cnt && id < w_thd_cnt + r_thd_cnt + s_thd_cnt);
+		output_thds[j].init(id,g_node_id,m_workload);
+		pthread_create(&p_threads[id++], NULL, work_thread, (void *)&output_thds[j]);
 	  }
 #if LOGGING
-    logger_thds[0].init(id,g_node_id,m_workload);
-    pthread_create(&p_threads[id++], NULL, work_thread, (void *)&logger_thds[0]);
+		logger_thds[0].init(id,g_node_id,m_workload);
+		pthread_create(&p_threads[id++], NULL, work_thread, (void *)&logger_thds[0]);
 #endif
 
 #if ALGO != CALVIN
-  abort_thds[0].init(id,g_node_id,m_workload);
-  pthread_create(&p_threads[id++], NULL, work_thread, (void *)&abort_thds[0]);
+	abort_thds[0].init(id,g_node_id,m_workload);
+	pthread_create(&p_threads[id++], NULL, work_thread, (void *)&abort_thds[0]);
 #endif
 
 #if ALGO == CALVIN
 #if SET_AFFINITY
-		CPU_ZERO(&cpus);
-    CPU_SET(cpus_cnt, &cpus);
-    pthread_attr_setaffinity_np(&attrib, sizeof(cpu_set_t), &cpus);
+	CPU_ZERO(&cpus);
+	CPU_SET(cpus_cnt, &cpus);
+	pthread_attr_setaffinity_np(&attrib, sizeof(cpu_set_t), &cpus);
 		cpus_cnt++;
 #endif
-
-  calvin_sched_thds[0].init(id,g_node_id,m_workload);
-  pthread_create(&p_threads[id++], &attrib, work_thread, (void *)&calvin_sched_thds[0]);
+	calvin_sched_thds[0].init(id,g_node_id,m_workload);
+	pthread_create(&p_threads[id++], &attrib, work_thread, (void *)&calvin_sched_thds[0]);
 #if SET_AFFINITY
-		CPU_ZERO(&cpus);
-    CPU_SET(cpus_cnt, &cpus);
-    pthread_attr_setaffinity_np(&attrib, sizeof(cpu_set_t), &cpus);
+	CPU_ZERO(&cpus);
+	CPU_SET(cpus_cnt, &cpus);
+	pthread_attr_setaffinity_np(&attrib, sizeof(cpu_set_t), &cpus);
 		cpus_cnt++;
 #endif
 
-  calvin_seq_thds[0].init(id,g_node_id,m_workload);
-  pthread_create(&p_threads[id++], &attrib, work_thread, (void *)&calvin_seq_thds[0]);
+	calvin_seq_thds[0].init(id,g_node_id,m_workload);
+	pthread_create(&p_threads[id++], &attrib, work_thread, (void *)&calvin_seq_thds[0]);
 #endif
 
 
@@ -263,23 +271,23 @@ int main(int argc, char* argv[])
 		pthread_join(p_threads[i], NULL);
 
 	endtime = get_serverdb_clock();
-	
-  fflush(stdout);
-  printf("PASS! SimTime = %f\n", (float)(endtime - begintime) / BILLION);
-  if (STATS_ENABLE)
-    stats.print(false);
-  //malloc_stats_print(NULL, NULL, NULL);
-  printf("\n");
-  fflush(stdout);
-  // Free things
+		
+	fflush(stdout);
+	printf("PASS! SimTime = %f\n", (float)(endtime - begintime) / BILLION);
+	if (STATS_ENABLE)
+		stats.print(false);
+	//malloc_stats_print(NULL, NULL, NULL);
+	printf("\n");
+	fflush(stdout);
+	// Free things
 	//tport_manager.shutdown();
-  m_workload->index_delete_all();
+	m_workload->index_delete_all();
 
 	return 0;
 }
 
 void * work_thread(void * id) {
-    Thread * thd = (Thread *) id;
+	Thread * thd = (Thread *) id;
 	thd->run();
 	return NULL;
 }
diff --git a/system/msg_queue.cpp b/system/msg_queue.cpp
index 55d9b50..99e987a 100644
--- a/system/msg_queue.cpp
+++ b/system/msg_queue.cpp
@@ -42,6 +42,8 @@ void MsgQueue::enqueue(uint64_t thd_id, Msg * message,uint64_t dest) {
 #if ALGO == CALVIN
   // Need to have strict message ordering for sequencer thread
   uint64_t rand = thd_id % g_send_thd_cnt_this;
+#elif WORKLOAD == DA
+  uint64_t rand = 0;
 #else
   uint64_t rand = mtx_time_begin % g_send_thd_cnt_this;
 #endif
@@ -72,6 +74,8 @@ uint64_t MsgQueue::dequeue(uint64_t thd_id, Msg *& message) {
     else
       valid = m_queue[thd_id%g_send_thd_cnt_this]->pop(entry);
   }
+#elif WORKLOAD == DA
+  valid = m_queue[0]->pop(entry);
 #else
   //uint64_t ctr_id = thd_id % g_send_thd_cnt_this;
   //uint64_t start_ctr = *ctr[ctr_id];
diff --git a/system/pool.cpp b/system/pool.cpp
index f5d395e..143523b 100644
--- a/system/pool.cpp
+++ b/system/pool.cpp
@@ -8,7 +8,8 @@
 #include "qry_ycsb.h"
 #include "ycsb.h"
 #include "qry_tpcc.h"
-
+#include "da.h"
+#include "da_query.h"
 #include "query.h"
 #include "msg_queue.h"
 #include "row.h"
@@ -25,14 +26,14 @@ void TxnManPool::init(WLSchema * wl, uint64_t size) {
   TxnMgr * txn;
   for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
 #if ALGO != CALVIN
-    pool[thd_id] = new boost::lockfree::queue<TxnMgr* > (size);
+	pool[thd_id] = new boost::lockfree::queue<TxnMgr* > (size);
 #endif
-    for(uint64_t i = 0; i < size; i++) {
-    //put(items[i]);
-      _wl->txn_get_manager(txn);
-      txn->init(thd_id,_wl);
-      put(thd_id, txn);
-    }
+	for(uint64_t i = 0; i < size; i++) {
+	//put(items[i]);
+	  _wl->txn_get_manager(txn);
+	  txn->init(thd_id,_wl);
+	  put(thd_id, txn);
+	}
   }
 }
 
@@ -43,7 +44,7 @@ void TxnManPool::get(uint64_t thd_id, TxnMgr *& item) {
   bool r = pool[thd_id]->pop(item);
 #endif
   if(!r) {
-    _wl->txn_get_manager(item);
+	_wl->txn_get_manager(item);
   }
   item->init(thd_id,_wl);
 }
@@ -57,7 +58,7 @@ void TxnManPool::put(uint64_t thd_id, TxnMgr * item) {
   while(!pool[thd_id]->push(item) && try_times++ < TRY_LIMIT) { }
 #endif
   if(try_times >= TRY_LIMIT) {
-    alloc_memory.free(item,sizeof(TxnMgr));
+	alloc_memory.free(item,sizeof(TxnMgr));
   }
 }
 
@@ -69,7 +70,7 @@ void TxnManPool::free_pool() {
 #else
   while(pool[thd_id]->pop(item)) {
 #endif
-    alloc_memory.free(item,sizeof(TxnMgr));
+	alloc_memory.free(item,sizeof(TxnMgr));
   }
   }
 }
@@ -84,14 +85,14 @@ void TxnPool::init(WLSchema * wl, uint64_t size) {
   Txn * txn;
   for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
 #if ALGO != CALVIN
-    pool[thd_id] = new boost::lockfree::queue<Txn*  > (size);
+	pool[thd_id] = new boost::lockfree::queue<Txn*  > (size);
 #endif
-    for(uint64_t i = 0; i < size; i++) {
-    //put(items[i]);
-    txn = (Txn*) alloc_memory.alloc(sizeof(Txn));
-    txn->init();
-    put(thd_id,txn);
-    }
+	for(uint64_t i = 0; i < size; i++) {
+	//put(items[i]);
+	txn = (Txn*) alloc_memory.alloc(sizeof(Txn));
+	txn->init();
+	put(thd_id,txn);
+	}
   }
 }
 
@@ -102,8 +103,8 @@ void TxnPool::get(uint64_t thd_id, Txn *& item) {
   bool r = pool[thd_id]->pop(item);
 #endif
   if(!r) {
-    item = (Txn*) alloc_memory.alloc(sizeof(Txn));
-    item->init();
+	item = (Txn*) alloc_memory.alloc(sizeof(Txn));
+	item->init();
   }
 }
 
@@ -117,83 +118,90 @@ void TxnPool::put(uint64_t thd_id,Txn * item) {
   while(!pool[thd_id]->push(item) && try_times++ < TRY_LIMIT) { }
 #endif
   if(try_times >= TRY_LIMIT) {
-    item->release(thd_id);
-    alloc_memory.free(item,sizeof(Txn));
+	item->release(thd_id);
+	alloc_memory.free(item,sizeof(Txn));
   }
 }
 
 void TxnPool::free_pool() {
   TxnMgr * item;
-    for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
+	for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
 #if ALGO == CALVIN
   while(pool->pop(item)) {
 #else
   while(pool[thd_id]->pop(item)) {
 #endif
-    alloc_memory.free(item,sizeof(item));
+	alloc_memory.free(item,sizeof(item));
 
   }
-    }
+	}
 }
 
 void QryPool::init(WLSchema * wl, uint64_t size) {
-  _wl = wl;
+  	_wl = wl;
 #if ALGO == CALVIN
-  pool = new boost::lockfree::queue<BaseQry* > (size);
+  	pool = new boost::lockfree::queue<BaseQry* > (size);
 #else
-  pool = new boost::lockfree::queue<BaseQry*> * [g_thread_total_cnt];
+  	pool = new boost::lockfree::queue<BaseQry*> * [g_thread_total_cnt];
 #endif
-  BaseQry * qry=NULL;
-  DEBUG_M("QryPool alloc init\n");
-  for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
+	BaseQry * qry=NULL;
+	DEBUG_M("QryPool alloc init\n");
+	for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
 #if ALGO != CALVIN
-    pool[thd_id] = new boost::lockfree::queue<BaseQry* > (size);
+	pool[thd_id] = new boost::lockfree::queue<BaseQry* > (size);
 #endif
-    for(uint64_t i = 0; i < size; i++) {
-    //put(items[i]);
+	for(uint64_t i = 0; i < size; i++) {
+	//put(items[i]);
 #if WORKLOAD==TPCC
-    QryTPCC * m_qry = (QryTPCC *) alloc_memory.alloc(sizeof(QryTPCC));
-    m_qry = new QryTPCC();
+	QryTPCC * m_qry = (QryTPCC *) alloc_memory.alloc(sizeof(QryTPCC));
+	m_qry = new QryTPCC();
 #elif WORKLOAD==YCSB
-    QryYCSB * m_qry = (QryYCSB *) alloc_memory.alloc(sizeof(QryYCSB));
-    m_qry = new QryYCSB();
+	QryYCSB * m_qry = (QryYCSB *) alloc_memory.alloc(sizeof(QryYCSB));
+	m_qry = new QryYCSB();
 #elif WORKLOAD==TEST
-    QryTPCC * m_qry = (QryTPCC *) alloc_memory.alloc(sizeof(QryTPCC));
-    m_qry = new QryTPCC();
+	QryTPCC * m_qry = (QryTPCC *) alloc_memory.alloc(sizeof(QryTPCC));
+	m_qry = new QryTPCC();
+#elif WORKLOAD==DA
+	DAQuery * m_qry = (DAQuery *) alloc_memory.alloc(sizeof(DAQuery));
+	m_qry = new DAQuery();
 #endif
-    m_qry->init();
-    qry = m_qry;
-    put(thd_id,qry);
-    }
+	m_qry->init();
+	qry = m_qry;
+	put(thd_id,qry);
+	}
   }
 }
 
 void QryPool::get(uint64_t thd_id, BaseQry *& item) {
 #if ALGO == CALVIN
-  bool r = pool->pop(item);
+  	bool r = pool->pop(item);
 #else
-  bool r = pool[thd_id]->pop(item);
+  	bool r = pool[thd_id]->pop(item);
 #endif
-  if(!r) {
-    DEBUG_M("query_pool alloc\n");
+	if(!r) {
+		DEBUG_M("query_pool alloc\n");
 #if WORKLOAD==TPCC
-    QryTPCC * qry = (QryTPCC *) alloc_memory.alloc(sizeof(QryTPCC));
-    qry = new QryTPCC();
+		QryTPCC * qry = (QryTPCC *) alloc_memory.alloc(sizeof(QryTPCC));
+		qry = new QryTPCC();
 #elif WORKLOAD==PPS
-    PPSQry * qry = (PPSQry *) alloc_memory.alloc(sizeof(PPSQry));
-    qry = new PPSQry();
+		PPSQry * qry = (PPSQry *) alloc_memory.alloc(sizeof(PPSQry));
+		qry = new PPSQry();
 #elif WORKLOAD==YCSB
-    QryYCSB * qry = NULL;
-    qry = (QryYCSB *) alloc_memory.alloc(sizeof(QryYCSB));
-    qry = new QryYCSB();
+		QryYCSB * qry = NULL;
+		qry = (QryYCSB *) alloc_memory.alloc(sizeof(QryYCSB));
+		qry = new QryYCSB();
 #elif WORKLOAD==TEST
-    QryTPCC * qry = (QryTPCC *) alloc_memory.alloc(sizeof(QryTPCC));
-    qry = new QryTPCC();
+		QryTPCC * qry = (QryTPCC *) alloc_memory.alloc(sizeof(QryTPCC));
+		qry = new QryTPCC();
+#elif WORKLOAD==DA
+		DAQuery * qry = NULL;
+		qry = (DAQuery *) alloc_memory.alloc(sizeof(DAQuery));
+		qry = new DAQuery();
 #endif
-    qry->init();
-    item = (BaseQry*)qry;
-  }
-  DEBUG_R("get 0x%lx\n",(uint64_t)item);
+		qry->init();
+		item = (BaseQry*)qry;
+	}
+	DEBUG_R("get 0x%lx\n",(uint64_t)item);
 }
 
 void QryPool::put(uint64_t thd_id, BaseQry * item) {
@@ -226,22 +234,22 @@ void QryPool::put(uint64_t thd_id, BaseQry * item) {
 #elif WORKLOAD == TEST
   ((QryTPCC*)item)->release();
 #endif
-    alloc_memory.free(item,sizeof(BaseQry));
+	alloc_memory.free(item,sizeof(BaseQry));
   }
 }
 
 void QryPool::free_pool() {
   BaseQry * item;
   DEBUG_M("query_pool free\n");
-    for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
+	for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
 #if ALGO == CALVIN
   while(pool->pop(item)) {
 #else
   while(pool[thd_id]->pop(item)) {
 #endif
-    alloc_memory.free(item,sizeof(item));
+	alloc_memory.free(item,sizeof(item));
   }
-    }
+	}
 }
 
 
@@ -250,11 +258,11 @@ void AccessPool::init(WLSchema * wl, uint64_t size) {
   pool = new boost::lockfree::queue<Access* > * [g_thread_total_cnt];
   DEBUG_M("AccessPool alloc init\n");
   for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
-    pool[thd_id] = new boost::lockfree::queue<Access* > (size);
-    for(uint64_t i = 0; i < size; i++) {
-    Access * item = (Access*)alloc_memory.alloc(sizeof(Access));
-    put(thd_id,item);
-    }
+	pool[thd_id] = new boost::lockfree::queue<Access* > (size);
+	for(uint64_t i = 0; i < size; i++) {
+	Access * item = (Access*)alloc_memory.alloc(sizeof(Access));
+	put(thd_id,item);
+	}
   }
 }
 
@@ -262,8 +270,8 @@ void AccessPool::get(uint64_t thd_id, Access *& item) {
   //bool r = pool->pop(item);
   bool r = pool[thd_id]->pop(item);
   if(!r) {
-    DEBUG_M("acc_pool alloc\n");
-    item = (Access*)alloc_memory.alloc(sizeof(Access));
+	DEBUG_M("acc_pool alloc\n");
+	item = (Access*)alloc_memory.alloc(sizeof(Access));
   }
 }
 
@@ -273,7 +281,7 @@ void AccessPool::put(uint64_t thd_id, Access * item) {
   int try_times = 0;
   while(!pool->push(item) && try_times++ < TRY_LIMIT) { }
   if(try_times >= TRY_LIMIT) {
-    alloc_memory.free(item,sizeof(Access));
+	alloc_memory.free(item,sizeof(Access));
   }
   */
 }
@@ -282,9 +290,9 @@ void AccessPool::free_pool() {
   Access * item;
   DEBUG_M("acc_pool free\n");
   //while(pool->pop(item)) {
-    for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
+	for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
   while(pool[thd_id]->pop(item)) {
-    alloc_memory.free(item,sizeof(item));
+	alloc_memory.free(item,sizeof(item));
   }
   }
 }
@@ -294,20 +302,20 @@ void TxnTablePool::init(WLSchema * wl, uint64_t size) {
   pool = new boost::lockfree::queue<txn_node* > * [g_thread_total_cnt];
   DEBUG_M("TxnTablePool alloc init\n");
   for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
-    pool[thd_id] = new boost::lockfree::queue<txn_node* > (size);
-    for(uint64_t i = 0; i < size; i++) {
-      txn_node * t_node = (txn_node *) alloc_memory.align_alloc(sizeof(struct txn_node));
-      //put(new txn_node());
-      put(thd_id,t_node);
-    }
+	pool[thd_id] = new boost::lockfree::queue<txn_node* > (size);
+	for(uint64_t i = 0; i < size; i++) {
+	  txn_node * t_node = (txn_node *) alloc_memory.align_alloc(sizeof(struct txn_node));
+	  //put(new txn_node());
+	  put(thd_id,t_node);
+	}
   }
 }
 
 void TxnTablePool::get(uint64_t thd_id, txn_node *& item) {
   bool r = pool[thd_id]->pop(item);
   if(!r) {
-    DEBUG_M("tbl_txn_pool alloc\n");
-    item = (txn_node *) alloc_memory.align_alloc(sizeof(struct txn_node));
+	DEBUG_M("tbl_txn_pool alloc\n");
+	item = (txn_node *) alloc_memory.align_alloc(sizeof(struct txn_node));
   }
 }
 
@@ -315,7 +323,7 @@ void TxnTablePool::put(uint64_t thd_id, txn_node * item) {
   int try_times = 0;
   while(!pool[thd_id]->push(item) && try_times++ < TRY_LIMIT) { }
   if(try_times >= TRY_LIMIT) {
-    alloc_memory.free(item,sizeof(txn_node));
+	alloc_memory.free(item,sizeof(txn_node));
   }
 }
 
@@ -323,9 +331,9 @@ void TxnTablePool::free_pool() {
   txn_node * item;
   DEBUG_M("tbl_txn_pool free\n");
   for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
-    while(pool[thd_id]->pop(item)) {
-      alloc_memory.free(item,sizeof(item));
-    }
+	while(pool[thd_id]->pop(item)) {
+	  alloc_memory.free(item,sizeof(item));
+	}
   }
 }
 void MsgPool::init(WLSchema * wl, uint64_t size) {
@@ -334,16 +342,16 @@ void MsgPool::init(WLSchema * wl, uint64_t size) {
   entry_message* entry;
   DEBUG_M("MsgPool alloc init\n");
   for(uint64_t i = 0; i < size; i++) {
-    entry = (entry_message*) alloc_memory.alloc(sizeof(struct entry_message));
-    put(entry);
+	entry = (entry_message*) alloc_memory.alloc(sizeof(struct entry_message));
+	put(entry);
   }
 }
 
 void MsgPool::get(entry_message* & item) {
   bool r = pool->pop(item);
   if(!r) {
-    DEBUG_M("message_pool alloc\n");
-    item = (entry_message*) alloc_memory.alloc(sizeof(struct entry_message));
+	DEBUG_M("message_pool alloc\n");
+	item = (entry_message*) alloc_memory.alloc(sizeof(struct entry_message));
   }
 }
 
@@ -354,7 +362,7 @@ void MsgPool::put(entry_message* item) {
   int try_times = 0;
   while(!pool->push(item) && try_times++ < TRY_LIMIT) { }
   if(try_times >= TRY_LIMIT) {
-    alloc_memory.free(item,sizeof(entry_message));
+	alloc_memory.free(item,sizeof(entry_message));
   }
 }
 
@@ -362,7 +370,7 @@ void MsgPool::free_pool() {
   entry_message * item;
   DEBUG_M("free message_pool\n");
   while(pool->pop(item)) {
-    alloc_memory.free(item,sizeof(item));
+	alloc_memory.free(item,sizeof(item));
   }
 }
 
@@ -372,19 +380,19 @@ void RowPool::init(WLSchema * wl, uint64_t size) {
   RowData* entry;
   DEBUG_M("init RowPool alloc\n");
   for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
-    pool[thd_id] = new boost::lockfree::queue<RowData* > (size);
-    for(uint64_t i = 0; i < size; i++) {
-    entry = (RowData*) alloc_memory.alloc(sizeof(struct RowData));
-    put(thd_id,entry);
-    }
+	pool[thd_id] = new boost::lockfree::queue<RowData* > (size);
+	for(uint64_t i = 0; i < size; i++) {
+	entry = (RowData*) alloc_memory.alloc(sizeof(struct RowData));
+	put(thd_id,entry);
+	}
   }
 }
 
 void RowPool::get(uint64_t thd_id, RowData* & item) {
   bool r = pool[thd_id]->pop(item);
   if(!r) {
-    DEBUG_M("alloc message_pool\n");
-    item = (RowData*) alloc_memory.alloc(sizeof(struct RowData));
+	DEBUG_M("alloc message_pool\n");
+	item = (RowData*) alloc_memory.alloc(sizeof(struct RowData));
   }
 }
 
@@ -392,7 +400,7 @@ void RowPool::put(uint64_t thd_id, RowData* item) {
   int try_times = 0;
   while(!pool[thd_id]->push(item) && try_times++ < TRY_LIMIT) { }
   if(try_times >= TRY_LIMIT) {
-    alloc_memory.free(item,sizeof(RowData));
+	alloc_memory.free(item,sizeof(RowData));
   }
 }
 
@@ -400,8 +408,8 @@ void RowPool::free_pool() {
   RowData * item;
   for(uint64_t thd_id = 0; thd_id < g_thread_total_cnt; thd_id++) {
   while(pool[thd_id]->pop(item)) {
-    DEBUG_M("free row_pool\n");
-    alloc_memory.free(item,sizeof(RowData));
+	DEBUG_M("free row_pool\n");
+	alloc_memory.free(item,sizeof(RowData));
   }
   }
 }
diff --git a/system/query.cpp b/system/query.cpp
index 46fbc5c..8beec4a 100644
--- a/system/query.cpp
+++ b/system/query.cpp
@@ -5,7 +5,7 @@
 #include "table.h"
 #include "qry_ycsb.h"
 #include "qry_tpcc.h"
-
+#include "da_query.h"
 
 /*************************************************/
 //     class Qry_queue
@@ -58,6 +58,8 @@ Qry_thd::init(WLSchema * h_wl, int thd_id) {
 		new(&queries[qid]) PPSQry();
 #elif WORKLOAD == TEST
 		new(&queries[qid]) QryTPCC();
+#elif WORKLOAD == DA
+		new(&queries[qid]) DAQuery();
 #endif
 		queries[qid].init(thd_id, h_wl);
 	}
diff --git a/system/query.h b/system/query.h
index 6b86e6e..fae7e72 100644
--- a/system/query.h
+++ b/system/query.h
@@ -10,6 +10,7 @@ class WLSchema;
 class QryYCSB;
 class QryTPCC;
 class PPSQry;
+class DAQuery;
 
 class BaseQry {
 public:
@@ -50,6 +51,8 @@ public:
 	PPSQry * queries;
 #elif WORKLOAD == TEST
 	QryTPCC * queries;
+#elif WORKLOAD == DA
+	DAQuery * queries;
 #endif
 	char pad[CL_SIZE - sizeof(void *) - sizeof(int)];
 };
diff --git a/system/sequencer.cpp b/system/sequencer.cpp
index 606c297..067d1f3 100644
--- a/system/sequencer.cpp
+++ b/system/sequencer.cpp
@@ -3,7 +3,7 @@
 #include "sequencer.h"
 #include "qry_ycsb.h"
 #include "qry_tpcc.h"
-
+#include "da_query.h"
 #include "mem_alloc.h"
 #include "transport.h"
 #include "workload.h"
@@ -76,7 +76,8 @@ void Sequencer::process_ack(Msg * message, uint64_t thd_id) {
       }
 #elif WORKLOAD == PPS
       PPSClientQueryMessage* cl_msg = (PPSClientQueryMessage*)wait_txn_list[id].message;
-
+#elif WORKLOAD == DA
+			DAClientQueryMessage* cl_msg = (DAClientQueryMessage*)wait_txn_list[id].message;
 #endif
 #if WORKLOAD == PPS
       if ( WORKLOAD == PPS && ALGO == CALVIN && ((cl_msg->txn_type == PPS_GETPARTBYSUPPLIER) ||
@@ -212,6 +213,8 @@ void Sequencer::process_txn( Msg * message,uint64_t thd_id, uint64_t early_start
     std::set<uint64_t> participants = PPSQry::participants(message,_wl);
 #elif WORKLOAD == TEST
     std::set<uint64_t> participants = QryTPCC::participants(message,_wl);
+#elif WORKLOAD == DA
+		std::set<uint64_t> participants = DAQuery::participants(message,_wl);
 #endif
     uint32_t server_ack_cnt = participants.size();
     assert(server_ack_cnt > 0);
diff --git a/system/sim_manager.cpp b/system/sim_manager.cpp
index 6c709ae..1e50140 100644
--- a/system/sim_manager.cpp
+++ b/system/sim_manager.cpp
@@ -18,6 +18,7 @@ void Simulator::init() {
 
 #if TIME_ENABLE
   run_begintime = acquire_ts();
+  last_da_query_time = acquire_ts();
 #else
   run_begintime = get_clock_wall();
 #endif
@@ -30,6 +31,7 @@ void Simulator::set_begintime(uint64_t begintime) {
     if(ATOM_CAS(start_set, false, true)) {
       run_begintime = begintime;
       last_worker_epoch_time = begintime;
+      last_da_query_time = begintime;
       sim_done = false;
       printf("Starttime set to %ld\n",run_begintime);
     } 
@@ -37,7 +39,22 @@ void Simulator::set_begintime(uint64_t begintime) {
 
 bool Simulator::timeout() {
 #if TIME_ENABLE
+	#if WORKLOAD == DA
+		uint64_t t=last_da_query_time;
+		uint64_t now=acquire_ts();
+		if(now<t)
+		{
+			now=t;
+		}
+		bool res =  ((acquire_ts() - run_begintime) >= (g_timer_done + g_warmup_timer)/12)
+		&&((now - t) >= (g_timer_done + g_warmup_timer)/6);
+		if (res) {
+			printf("123\n");
+		}
+		return res;
+	#else
   return (acquire_ts() - run_begintime) >= g_timer_done + g_warmup_timer;
+  #endif
 #else
   return (get_clock_wall() - run_begintime) >= g_timer_done + g_warmup_timer;
 #endif
@@ -52,6 +69,9 @@ bool Simulator::is_done() {
 }
 
 bool Simulator::is_warmup_done() {
+	#if WORKLOAD == DA
+		return true;
+	#endif
   if(warmup)
     return true;
   bool done = ((acquire_ts() - run_begintime) >= g_warmup_timer);
diff --git a/system/sim_manager.h b/system/sim_manager.h
index c7cecd2..4830b39 100644
--- a/system/sim_manager.h
+++ b/system/sim_manager.h
@@ -21,7 +21,7 @@ public:
   int64_t epoch_txn_cnt;
   uint64_t txn_cnt;
   uint64_t inflight_cnt;
-
+  uint64_t last_da_query_time;
   void init();
   bool is_setup_done();
   bool is_done();
diff --git a/system/task_thread.cpp b/system/task_thread.cpp
index 93ed92b..cc749e5 100644
--- a/system/task_thread.cpp
+++ b/system/task_thread.cpp
@@ -22,7 +22,7 @@
 void TaskThread::setup() {
 
 	if( read_thd_id() == 0) {
-    send_init_done_to_nodes();
+	send_init_done_to_nodes();
   }
   _thd_txn_id = 0;
 
@@ -95,11 +95,11 @@ void TaskThread::process(Msg * message) {
 
 void TaskThread::check_if_done(RC rc) {
   if(txn_man->waiting_for_rps())
-    return;
+	return;
   if(rc == Commit)
-    commit();
+	commit();
   if(rc == Abort)
-    abort();
+	abort();
 }
 
 void TaskThread::release_txn_manager() {
@@ -147,10 +147,10 @@ void TaskThread::abort() {
 
   ++txn_man->abort_cnt;
   txn_man->reset();
-
+#if WORKLOAD != DA
   uint64_t penalty = abort_queue.enqueue(read_thd_id(), txn_man->read_txn_id(),txn_man->get_abort_cnt());
-
   txn_man->txn_stats.total_abort_time += penalty;
+#endif
 
 }
 
@@ -163,6 +163,25 @@ TxnMgr * TaskThread::get_transaction_manager(Msg * message) {
   return local_txn_man;
 }
 
+char type2char(DATxnType txn_type)
+{
+  switch (txn_type)
+  {
+    case DA_READ:
+      return 'R';
+    case DA_WRITE:
+      return 'W';
+    case DA_COMMIT:
+      return 'C';
+    case DA_ABORT:
+      return 'A';
+    case DA_SCAN:
+      return 'S';
+    default:
+      return 'U';
+  }
+}
+
 RC TaskThread::run() {
   tsetup();
   printf("Running TaskThread %ld\n",_thd_id);
@@ -175,14 +194,35 @@ RC TaskThread::run() {
     heartbeat();
 
     progress_stats();
-
-    Msg * message = task_queue.dequeue(read_thd_id());
-
+    Msg * message;
+    // #define TEST_MSG_order
+    #ifdef TEST_MSG_order
+      while(1)
+      {
+      message = task_queue.dequeue(read_thd_id());
+      if (!message) {
+        if (idle_starttime == 0) idle_starttime = acquire_ts();
+        continue;
+      }
+      printf("s seq_id:%lu type:%c trans_id:%lu item:%c state:%lu next_state:%lu\n",
+      ((DAClientQueryMessage*)message)->seq_id,
+      type2char(((DAClientQueryMessage*)message)->txn_type),
+      ((DAClientQueryMessage*)message)->trans_id,
+      static_cast<char>('x'+((DAClientQueryMessage*)message)->item_id),
+      ((DAClientQueryMessage*)message)->state,
+      (((DAClientQueryMessage*)message)->next_state));
+      fflush(stdout);
+      }
+    #endif
+    message = task_queue.dequeue(read_thd_id());
     if(!message) {
       if(idle_starttime ==0)
-        idle_starttime = acquire_ts();
+      idle_starttime = acquire_ts();
       continue;
     }
+
+    simulate_man->last_da_query_time = acquire_ts();
+
     if(idle_starttime > 0) {
       INC_STATS(_thd_id,worker_idle_time,acquire_ts() - idle_starttime);
       idle_starttime = 0;
@@ -192,60 +232,56 @@ RC TaskThread::run() {
     if(message->rtype != WKCQRY || ALGO == CALVIN) {
       txn_man = get_transaction_manager(message);
 
-      if (ALGO != CALVIN && IS_LOCAL(txn_man->read_txn_id())) {
-        if (message->rtype != WKRTXN_CONT && ((message->rtype != WKRACK_PREP) || (txn_man->get_rsp_cnt() == 1))) {
-          txn_man->txn_stats.task_queue_time_short += message->lat_task_queue_time;
-          txn_man->txn_stats.cc_block_time_short += message->lat_cc_block_time;
-          txn_man->txn_stats.cc_time_short += message->lat_cc_time;
-          txn_man->txn_stats.msg_queue_time_short += message->lat_msg_queue_time;
-          txn_man->txn_stats.process_time_short += message->lat_process_time;
-          /*
-          if (message->lat_network_time/BILLION > 1.0) {
-            printf("%ld %d %ld -> %ld: %f %f\n",message->txn_id, message->rtype, message->return_node_id,get_node_id() ,message->lat_network_time/BILLION, message->lat_other_time/BILLION);
-          } 
-          */
-          txn_man->txn_stats.network_time_short += message->lat_network_time;
-        }
-
-      } else {
-          txn_man->txn_stats.clear_short();
-      }
-      if (ALGO != CALVIN) {
-        txn_man->txn_stats.lat_network_time_start = message->lat_network_time;
-        txn_man->txn_stats.lat_other_time_start = message->lat_other_time;
-      }
-      txn_man->txn_stats.msg_queue_time += message->mq_time;
-      txn_man->txn_stats.msg_queue_time_short += message->mq_time;
-      message->mq_time = 0;
-      txn_man->txn_stats.task_queue_time += message->wq_time;
-      txn_man->txn_stats.task_queue_time_short += message->wq_time;
-      //txn_man->txn_stats.network_time += message->ntwk_time;
-      message->wq_time = 0;
-      txn_man->txn_stats.task_queue_cnt += 1;
-
-
-      ready_starttime = acquire_ts();
-      bool ready = txn_man->unset_ready();
-      INC_STATS(read_thd_id(),worker_activate_txn_time,acquire_ts() - ready_starttime);
-      if(!ready) {
-        // Return to work queue, end processing
-        task_queue.enqueue(read_thd_id(),message,true);
-        continue;
-      }
-      txn_man->register_thread(this);
-    }
+	  if (ALGO != CALVIN && IS_LOCAL(txn_man->read_txn_id())) {
+		if (message->rtype != WKRTXN_CONT && ((message->rtype != WKRACK_PREP) || (txn_man->get_rsp_cnt() == 1))) {
+		  txn_man->txn_stats.task_queue_time_short += message->lat_task_queue_time;
+		  txn_man->txn_stats.cc_block_time_short += message->lat_cc_block_time;
+		  txn_man->txn_stats.cc_time_short += message->lat_cc_time;
+		  txn_man->txn_stats.msg_queue_time_short += message->lat_msg_queue_time;
+  	  txn_man->txn_stats.process_time_short += message->lat_process_time;
 
-    process(message);
+		  txn_man->txn_stats.network_time_short += message->lat_network_time;
+		}
 
-    ready_starttime = acquire_ts();
-    if(txn_man) {
-      bool ready = txn_man->set_ready();
-      assert(ready);
-    }
-    INC_STATS(read_thd_id(),worker_deactivate_txn_time,acquire_ts() - ready_starttime);
+	  } else {
+		  txn_man->txn_stats.clear_short();
+	  }
+	  if (ALGO != CALVIN) {
+      txn_man->txn_stats.lat_network_time_start = message->lat_network_time;
+      txn_man->txn_stats.lat_other_time_start = message->lat_other_time;
+	  }
+	  txn_man->txn_stats.msg_queue_time += message->mq_time;
+	  txn_man->txn_stats.msg_queue_time_short += message->mq_time;
+	  message->mq_time = 0;
+	  txn_man->txn_stats.task_queue_time += message->wq_time;
+	  txn_man->txn_stats.task_queue_time_short += message->wq_time;
+	  //txn_man->txn_stats.network_time += message->ntwk_time;
+	  message->wq_time = 0;
+	  txn_man->txn_stats.task_queue_cnt += 1;
+
+
+	  ready_starttime = acquire_ts();
+	  bool ready = txn_man->unset_ready();
+	  INC_STATS(read_thd_id(),worker_activate_txn_time,acquire_ts() - ready_starttime);
+	  if(!ready) {
+      // Return to work queue, end processing
+      task_queue.enqueue(read_thd_id(),message,true);
+      continue;
+	  }
+	  txn_man->register_thread(this);
+	}
+
+	process(message);
 
-    // delete message
-    ready_starttime = acquire_ts();
+	ready_starttime = acquire_ts();
+	if(txn_man) {
+	  bool ready = txn_man->set_ready();
+	  assert(ready);
+	}
+	INC_STATS(read_thd_id(),worker_deactivate_txn_time,acquire_ts() - ready_starttime);
+
+	// delete message
+	ready_starttime = acquire_ts();
 #if ALGO != CALVIN
     message->release();
 #endif
@@ -294,32 +330,32 @@ RC TaskThread::rack_prep_process(Msg * message) {
   uint64_t lower = ((AckMessage*)message)->lower;
   uint64_t upper = ((AckMessage*)message)->upper;
   if(lower > txn_timestamp_bounds.get_lower(read_thd_id(),message->read_txn_id())) {
-    txn_timestamp_bounds.set_lower(read_thd_id(),message->read_txn_id(),lower);
+	txn_timestamp_bounds.set_lower(read_thd_id(),message->read_txn_id(),lower);
   }
   if(upper < txn_timestamp_bounds.get_upper(read_thd_id(),message->read_txn_id())) {
-    txn_timestamp_bounds.set_upper(read_thd_id(),message->read_txn_id(),upper);
+	txn_timestamp_bounds.set_upper(read_thd_id(),message->read_txn_id(),upper);
   }
   DEBUG("%ld bound set: [%ld,%ld] -> [%ld,%ld]\n",message->read_txn_id(),lower,upper,txn_timestamp_bounds.get_lower(read_thd_id(),message->read_txn_id()),txn_timestamp_bounds.get_upper(read_thd_id(),message->read_txn_id()));
   if(((AckMessage*)message)->rc != RCOK) {
-    txn_timestamp_bounds.set_state(read_thd_id(),message->read_txn_id(),TEMPLATE_ABORTED);
+	txn_timestamp_bounds.set_state(read_thd_id(),message->read_txn_id(),TEMPLATE_ABORTED);
   }
 #endif
   if(responses_left > 0) 
-    return WAIT;
+	return WAIT;
 
   // Done waiting 
   if(txn_man->get_rc() == RCOK) {
-    rc  = txn_man->validate();
+	rc  = txn_man->validate();
   }
   if(rc == Abort || txn_man->get_rc() == Abort) {
-    txn_man->txn->rc = Abort;
-    rc = Abort;
+	txn_man->txn->rc = Abort;
+	rc = Abort;
   }
   txn_man->send_finish_msg();
   if(rc == Abort) {
-    txn_man->abort();
+	txn_man->abort();
   } else {
-    txn_man->commit();
+	txn_man->commit();
   }
 
   return rc;
@@ -333,17 +369,17 @@ RC TaskThread::rack_rfin_process(Msg * message) {
   int responses_left = txn_man->received_rps(((AckMessage*)message)->rc);
   assert(responses_left >=0);
   if(responses_left > 0) 
-    return WAIT;
+	return WAIT;
 
   // Done waiting 
   txn_man->txn_stats.two_pc_time += acquire_ts() - txn_man->txn_stats.wait_begintime;
 
   if(txn_man->get_rc() == RCOK) {
-    //txn_man->commit();
-    commit();
+	//txn_man->commit();
+	commit();
   } else {
-    //txn_man->abort();
-    abort();
+	//txn_man->abort();
+	abort();
   }
   return rc;
 }
@@ -355,8 +391,8 @@ RC TaskThread::rqry_rsp_process(Msg * message) {
   txn_man->txn_stats.remote_wait_time += acquire_ts() - txn_man->txn_stats.wait_begintime;
 
   if(((QueryResponseMessage*)message)->rc == Abort) {
-    txn_man->start_abort();
-    return Abort;
+	txn_man->start_abort();
+	return Abort;
   }
 
   RC rc = txn_man->run_txn();
@@ -438,60 +474,103 @@ uint64_t TaskThread::get_next_txn_id() {
 }
 
 RC TaskThread::rtxn_process(Msg * message) {
-        RC rc = RCOK;
-        uint64_t txn_id = UINT64_MAX;
-
-        if(message->get_rtype() == WKCQRY) {
-          // This is a new transaction
-
-					// Only set new txn_id when txn first starts
-          txn_id = get_next_txn_id();
-          message->txn_id = txn_id;
-
-					// Put txn in txn_table
-          txn_man = txn_table.get_transaction_manager(read_thd_id(),txn_id,0);
-          txn_man->register_thread(this);
-          uint64_t ready_starttime = acquire_ts();
-          bool ready = txn_man->unset_ready();
-          INC_STATS(read_thd_id(),worker_activate_txn_time,acquire_ts() - ready_starttime);
-          assert(ready);
-					// if (ALGO == WAIT_DIE) {
-          //   txn_man->set_timestamp(get_next_ts());
-          // }
-          txn_man->txn_stats.begintime = acquire_ts();
-          txn_man->txn_stats.restart_begintime = txn_man->txn_stats.begintime;
-          message->copy_to_txn(txn_man);
-          DEBUG("START %ld %f %lu\n",txn_man->read_txn_id(),simulate_man->seconds_from_begin(acquire_ts()),txn_man->txn_stats.begintime);
-          INC_STATS(read_thd_id(),local_txn_start_cnt,1);
-
-        } else {
-            txn_man->txn_stats.restart_begintime = acquire_ts();
-          DEBUG("RESTART %ld %f %lu\n",txn_man->read_txn_id(),simulate_man->seconds_from_begin(acquire_ts()),txn_man->txn_stats.begintime);
-        }
-
-          // Get new timestamps
-          if(is_cc_new_timestamp()) {
-            txn_man->set_timestamp(get_next_ts());
-					}
-
+  RC rc = RCOK;
+  uint64_t txn_id = UINT64_MAX;
+
+  if(message->get_rtype() == WKCQRY) {
+    // This is a new transaction
+
+    // Only set new txn_id when txn first starts
+    #if WORKLOAD == DA
+    message->txn_id=((DAClientQueryMessage*)message)->trans_id;
+    txn_id=((DAClientQueryMessage*)message)->trans_id;
+    #else
+    txn_id = get_next_txn_id();
+    message->txn_id = txn_id;
+    #endif
+
+    // Put txn in txn_table
+    txn_man = txn_table.get_transaction_manager(read_thd_id(),txn_id,0);
+    txn_man->register_thread(this);
+    uint64_t ready_starttime = acquire_ts();
+    bool ready = txn_man->unset_ready();
+    INC_STATS(read_thd_id(),worker_activate_txn_time,acquire_ts() - ready_starttime);
+    assert(ready);
+
+    txn_man->txn_stats.begintime = acquire_ts();
+    txn_man->txn_stats.restart_begintime = txn_man->txn_stats.begintime;
+    message->copy_to_txn(txn_man);
+    DEBUG("START %ld %f %lu\n",txn_man->read_txn_id(),simulate_man->seconds_from_begin(acquire_ts()),txn_man->txn_stats.begintime);
+  #if WORKLOAD==DA
+    if(da_start_trans_tab.count(txn_man->read_txn_id())==0)
+    {
+      da_start_trans_tab.insert(txn_man->read_txn_id());
+      INC_STATS(read_thd_id(),local_txn_start_cnt,1);
+    }
+  #else
+    INC_STATS(read_thd_id(), local_txn_start_cnt, 1);
+  #endif
+  } else {
+    txn_man->txn_stats.restart_begintime = acquire_ts();
+    DEBUG("RESTART %ld %f %lu\n",txn_man->read_txn_id(),simulate_man->seconds_from_begin(acquire_ts()),txn_man->txn_stats.begintime);
+  }
+      // Get new timestamps
+  if(is_cc_new_timestamp()) {
+  #if WORKLOAD==DA //mvcc use timestamp
+    if(da_stamp_tab.count(txn_man->read_txn_id())==0)
+    {
+      da_stamp_tab[txn_man->read_txn_id()]=get_next_ts();
+      txn_man->set_timestamp(da_stamp_tab[txn_man->read_txn_id()]);
+    }
+  else
+    txn_man->set_timestamp(da_stamp_tab[txn_man->read_txn_id()]);
+  #else
+    txn_man->set_timestamp(get_next_ts());
+  #endif
+  }
 #if ALGO == TEMPLATE
-          txn_timestamp_bounds.init(read_thd_id(),txn_man->read_txn_id());
-          assert(txn_timestamp_bounds.get_lower(read_thd_id(),txn_man->read_txn_id()) == 0);
-          assert(txn_timestamp_bounds.get_upper(read_thd_id(),txn_man->read_txn_id()) == UINT64_MAX);
-          assert(txn_timestamp_bounds.get_state(read_thd_id(),txn_man->read_txn_id()) == TEMPLATE_RUNNING);
+  #if WORKLOAD==DA
+  if(da_start_stamp_tab.count(txn_man->read_txn_id())==0)
+  {
+    da_start_stamp_tab[txn_man->read_txn_id()]=1;
+    txn_timestamp_bounds.init(read_thd_id(),txn_man->read_txn_id());
+    assert(txn_timestamp_bounds.get_lower(read_thd_id(),txn_man->read_txn_id()) == 0);
+    assert(txn_timestamp_bounds.get_upper(read_thd_id(),txn_man->read_txn_id()) == UINT64_MAX);
+    assert(txn_timestamp_bounds.get_state(read_thd_id(),txn_man->read_txn_id()) == TEMPLATE_RUNNING);
+  }
+  #else
+  txn_timestamp_bounds.init(read_thd_id(),txn_man->read_txn_id());
+  assert(txn_timestamp_bounds.get_lower(read_thd_id(),txn_man->read_txn_id()) == 0);
+  assert(txn_timestamp_bounds.get_upper(read_thd_id(),txn_man->read_txn_id()) == UINT64_MAX);
+  assert(txn_timestamp_bounds.get_state(read_thd_id(),txn_man->read_txn_id()) == TEMPLATE_RUNNING);
+  #endif
 #endif
 
-    rc = init_phase();
-    if(rc != RCOK)
-      return rc;
-
-    // Execute transaction
-    if (WORKLOAD == TEST)
-      rc = runTest(txn_man);
-    else 
-      rc = txn_man->run_txn();
-  check_if_done(rc);
-    return rc;
+	rc = init_phase();
+	if(rc != RCOK)
+	  	return rc;
+	#if WORKLOAD == DA
+		printf("thd_id:%lu stxn_id:%lu batch_id:%lu seq_id:%lu type:%c rtype:%d trans_id:%lu item:%c laststate:%lu state:%lu next_state:%lu\n",
+		this->_thd_id,
+		((DAClientQueryMessage*)message)->txn_id,
+		((DAClientQueryMessage*)message)->batch_id,
+		((DAClientQueryMessage*)message)->seq_id,
+		type2char(((DAClientQueryMessage*)message)->txn_type),
+		((DAClientQueryMessage*)message)->rtype,
+		((DAClientQueryMessage*)message)->trans_id,
+		static_cast<char>('x'+((DAClientQueryMessage*)message)->item_id),
+		((DAClientQueryMessage*)message)->last_state,
+		((DAClientQueryMessage*)message)->state,
+		((DAClientQueryMessage*)message)->next_state);
+		fflush(stdout);
+	#endif
+	// Execute transaction
+	if (WORKLOAD == TEST)
+	  	rc = runTest(txn_man);
+	else 
+	  	rc = txn_man->run_txn();
+  	check_if_done(rc);
+	return rc;
 }
 
 RC TaskThread::runTest(TxnMgr * txn)
@@ -559,12 +638,12 @@ RC TaskThread::rfwd_process(Msg * message) {
   int responses_left = txn_man->received_rps(((ForwardMessage*)message)->rc);
   assert(responses_left >=0);
   if(txn_man->calvin_collect_phase_done()) {
-    assert(ISSERVERN(txn_man->return_id));
-    RC rc = txn_man->run_calvin_txn();
-    if(rc == RCOK && txn_man->calvin_exec_phase_done()) {
-      calvin_wrapup();
-      return RCOK;
-    }   
+	assert(ISSERVERN(txn_man->return_id));
+	RC rc = txn_man->run_calvin_txn();
+	if(rc == RCOK && txn_man->calvin_exec_phase_done()) {
+	  calvin_wrapup();
+	  return RCOK;
+	}   
   }
   return WAIT;
 
@@ -579,7 +658,7 @@ RC TaskThread::calvin_rtxn_process(Msg * message) {
   RC rc = txn_man->run_calvin_txn();
   //if((txn_man->phase==6 && rc == RCOK) || txn_man->active_cnt == 0 || txn_man->participant_cnt == 1) {
   if(rc == RCOK && txn_man->calvin_exec_phase_done()) {
-    calvin_wrapup();
+	calvin_wrapup();
   }
   return RCOK;
 
diff --git a/system/txn.cpp b/system/txn.cpp
index 571aecb..d516bfc 100644
--- a/system/txn.cpp
+++ b/system/txn.cpp
@@ -739,16 +739,31 @@ RC TxnMgr::get_row(RowData * row, access_t type, RowData *& row_rtn) {
     uint64_t timespan;
     RC rc = RCOK;
     DEBUG_M("TxnMgr::get_row access alloc\n");
-    Access * access;
-    acc_pool.get(read_thd_id(),access);
+    Access * access = NULL;
+
     //uint64_t row_cnt = txn->row_cnt;
     //assert(txn->access.get_count() - 1 == row_cnt);
+    bool isexist = false;
+    uint64_t size = sizeof_write_set();
+    size += sizeof_read_set();
+    // UInt32 n = 0, m = 0;
+    for (uint64_t i = 0; i < size; i++) {
+      if (txn->access[i]->type == WR && 
+        txn->access[i]->orig_row == row) {
+        access = txn->access[i];
+        isexist = true;
+        break;
+      }
+    }
+    if (!access) {
+      acc_pool.get(read_thd_id(),access);
+      rc = row->get_row(type, this, access->data);
+      access->type = type;
+    }
 
     this->last_row = row;
     this->last_type = type;
 
-    rc = row->get_row(type, this, access->data);
-
     if (rc == Abort || rc == WAIT) {
         row_rtn = NULL;
         DEBUG_M("TxnMgr::get_row(abort) access free\n");
@@ -762,8 +777,8 @@ RC TxnMgr::get_row(RowData * row, access_t type, RowData *& row_rtn) {
 #endif
         return rc;
     }
-	access->type = type;
-	access->orig_row = row;
+	  // access->type = type;
+	  access->orig_row = row;
 #if ROLL_BACK && (ALGO == DL_DETECT || ALGO == HSTORE || ALGO == HSTORE_SPEC)
 	if (type == WR) {
     //printf("alloc 10 %ld\n",read_txn_id());
@@ -787,11 +802,12 @@ RC TxnMgr::get_row(RowData * row, access_t type, RowData *& row_rtn) {
 	}
 #endif
 
-	++txn->row_cnt;
-	if (type == WR)
-		++txn->write_cnt;
-
-  txn->access.add(access);
+	if (!isexist) {
+		++txn->row_cnt;
+		if (type == WR)
+			++txn->write_cnt;
+		txn->access.add(access);
+	}
 
 	timespan = acquire_ts() - begintime;
 	INC_STATS(read_thd_id(), txn_manager_time, timespan);
diff --git a/system/txn_table.cpp b/system/txn_table.cpp
index 10b3232..6b6691a 100644
--- a/system/txn_table.cpp
+++ b/system/txn_table.cpp
@@ -29,18 +29,17 @@ void TxnTable::init() {
 }
 
 void TxnTable::dump() {
-  for(uint64_t i = 0; i < pool_size;i++) {
-    if(pool[i]->cnt  == 0)
-      continue;
-      txn_node_t t_node = pool[i]->head;
-
-      while (t_node != NULL) {
-        printf("TT (%ld,%ld)\n",t_node->txn_man->read_txn_id(),t_node->txn_man->get_batch_id()
-            );
-        t_node = t_node->next;
-      }
-      
-  }
+    for(uint64_t i = 0; i < pool_size;i++) {
+        if(pool[i]->cnt  == 0) {continue;}
+    
+        txn_node_t t_node = pool[i]->head;
+
+        while (t_node != NULL) {
+            printf("TT (%ld,%ld)\n",t_node->txn_man->read_txn_id(),t_node->txn_man->get_batch_id());
+            t_node = t_node->next;
+        }
+        
+    }
 }
 
 bool TxnTable::is_matching_txn_node(txn_node_t t_node, uint64_t txn_id, uint64_t batch_id){
diff --git a/system/workload.cpp b/system/workload.cpp
index 3c4ec12..4d6a02d 100644
--- a/system/workload.cpp
+++ b/system/workload.cpp
@@ -116,6 +116,10 @@ RC WLSchema::init_schema(const char * schema_file) {
       else if ( !tname.compare(1, 4, "USES") ) {
         table_size = MAX_PPS_SUPPLIER_KEY;
       }
+#elif WORKLOAD == DA
+      if (!tname.compare(1, 5, "DAtab")) {
+        table_size = MAX_DA_TABLE_SIZE;
+      }
 #else
       table_size = g_table_size_synth / g_cnt_part;
 #endif
@@ -135,12 +139,11 @@ RC WLSchema::init_schema(const char * schema_file) {
 
 
 void WLSchema::index_delete_all() {
-  /*
-  for (auto string index_name = indexes.keys(); index_name = index_name.next()) {
-    INDEX * index = (INDEX *) indexes[index_name];
-    index->delete_this_index();
-  }
-  */
+  #if WORKLOAD ==DA
+    for (auto index :indexes) {
+      index.second->index_reset();
+    }
+  #endif
 }
 
 void WLSchema::index_insert(string index_name, uint64_t key, RowData * row) {
diff --git a/transport/message.cpp b/transport/message.cpp
index 814a9ce..52c5680 100644
--- a/transport/message.cpp
+++ b/transport/message.cpp
@@ -8,6 +8,8 @@
 #include "global.h"
 #include "message.h"
 #include "_template.h"
+#include "da.h"
+#include "da_query.h"
 
 std::vector<Msg*> * Msg::create_messages(char * buf) {
   std::vector<Msg*> * all_msgs = new std::vector<Msg*>;
@@ -75,6 +77,8 @@ Msg * Msg::create_message(BaseQry * query, RemReqType rtype) {
  ((QueryMsgClientTPCC*)message)->copy_from_query(query);
 #elif WORKLOAD == PPS 
  ((PPSClientQueryMessage*)message)->copy_from_query(query);
+#elif  WORKLOAD == DA
+  ((DAClientQueryMessage*)message)->copy_from_query(query);
 #endif
  return message;
 }
@@ -108,6 +112,8 @@ Msg * Msg::create_message(RemReqType rtype) {
       message = new PPSQueryMessage;
 #elif WORKLOAD == TEST
       message = new QueryMsgTPCC;
+#elif WORKLOAD == DA
+      message = new DAQueryMessage;
 #endif
       message->init();
       break;
@@ -142,6 +148,8 @@ Msg * Msg::create_message(RemReqType rtype) {
       message = new PPSClientQueryMessage;
 #elif WORKLOAD == TEST
       message = new QueryMsgClientTPCC;
+#elif WORKLOAD == DA
+      message = new DAClientQueryMessage;
 #endif
       message->init();
       break;
@@ -272,6 +280,8 @@ void Msg::release_message(Msg * message) {
       QueryMsgTPCC * m_msg = (QueryMsgTPCC*)message;
 #elif WORKLOAD == TEST
       QueryMsgTPCC * m_msg = (QueryMsgTPCC*)message;
+#elif WORKLOAD == DA
+      DAQueryMessage* m_msg = (DAQueryMessage*)message;
 #endif
       m_msg->release();
       delete m_msg;
@@ -326,6 +336,8 @@ void Msg::release_message(Msg * message) {
       PPSClientQueryMessage * m_msg = (PPSClientQueryMessage*)message;
 #elif WORKLOAD == TEST
       QueryMsgClientTPCC * m_msg = (QueryMsgClientTPCC*)message;
+#elif WORKLOAD == DA
+      DAClientQueryMessage* m_msg = (DAClientQueryMessage*)message;
 #endif
       m_msg->release();
       delete m_msg;
@@ -644,6 +656,84 @@ void QueryMsgClientTPCC::copy_to_buf(char * buf) {
  assert(ptr == get_size());
 }
 
+
+/***************DA zone*********/
+void DAClientQueryMessage::init() {}
+void DAClientQueryMessage::copy_from_query(BaseQry* query) {
+  ClientQryMsg::copy_from_query(query);
+  DAQuery* da_query = (DAQuery*)(query);
+
+  txn_type= da_query->txn_type;
+	trans_id= da_query->trans_id;
+	item_id= da_query->item_id;
+	seq_id= da_query->seq_id;
+	write_version=da_query->write_version;
+  state= da_query->state;
+	next_state= da_query->next_state;
+	last_state= da_query->last_state;
+}
+void DAClientQueryMessage::copy_to_buf(char* buf) {
+  ClientQryMsg::copy_to_buf(buf);
+  uint64_t ptr = ClientQryMsg::get_size();
+
+  COPY_BUF(buf, txn_type, ptr);
+  COPY_BUF(buf, trans_id, ptr);
+  COPY_BUF(buf, item_id, ptr);
+  COPY_BUF(buf, seq_id, ptr);
+  COPY_BUF(buf, write_version, ptr);
+  COPY_BUF(buf, state, ptr);
+  COPY_BUF(buf, next_state, ptr);
+  COPY_BUF(buf, last_state, ptr);
+  assert(ptr == get_size());
+}
+void DAClientQueryMessage::copy_from_txn(TxnMgr* txn) {
+  ClientQryMsg::mcopy_from_txn(txn);
+  copy_from_query(txn->query);
+}
+
+void DAClientQueryMessage::copy_from_buf(char* buf) {
+  ClientQryMsg::copy_from_buf(buf);
+  uint64_t ptr = ClientQryMsg::get_size();
+
+  COPY_VAL(txn_type, buf, ptr);
+  // common txn input for both payment & new-order
+  COPY_VAL(trans_id, buf, ptr);
+  COPY_VAL(item_id, buf, ptr);
+  COPY_VAL(seq_id, buf, ptr);
+  COPY_VAL(write_version, buf, ptr);
+  // payment
+  COPY_VAL(state, buf, ptr);
+  COPY_VAL(next_state, buf, ptr);
+  COPY_VAL(last_state, buf, ptr);
+  assert(ptr == get_size());
+}
+
+void DAClientQueryMessage::copy_to_txn(TxnMgr* txn) {
+  ClientQryMsg::copy_to_txn(txn);
+  DAQuery* da_query = (DAQuery*)(txn->query);
+
+
+  txn->client_id = return_node_id;
+  da_query->txn_type = (DATxnType)txn_type;
+  da_query->trans_id = trans_id;
+  da_query->item_id = item_id;
+  da_query->seq_id = seq_id;
+  da_query->write_version = write_version;
+  da_query->state = state;
+  da_query->next_state = next_state;
+  da_query->last_state = last_state;
+
+}
+
+uint64_t DAClientQueryMessage::get_size() {
+  uint64_t size = ClientQryMsg::get_size();
+  size += sizeof(DATxnType);
+  size += sizeof(uint64_t) * 7;
+  return size;
+
+}
+void DAClientQueryMessage::release() { ClientQryMsg::release(); }
+
 /************************/
 
 void ClientQryMsg::init() {
@@ -1367,4 +1457,91 @@ void QueryMsgTPCC::copy_to_buf(char * buf) {
   }
  assert(ptr == get_size());
 
-}
\ No newline at end of file
+}
+
+//---DAquerymessage zone------------
+
+void DAQueryMessage::init() {}
+/*
+void DAQueryMessage::copy_from_query(BaseQuery* query) {
+  QueryMessage::copy_from_query(query);
+  DAQuery* da_query = (DAQuery*)(query);
+
+  txn_type= da_query->txn_type;
+	trans_id= da_query->trans_id;
+	item_id= da_query->item_id;
+	seq_id= da_query->seq_id;
+	write_version=da_query->write_version;
+  state= da_query->state;
+	next_state= da_query->next_state;
+	last_state= da_query->last_state;
+}*/
+void DAQueryMessage::copy_to_buf(char* buf) {
+  QueryMessage::copy_to_buf(buf);
+  uint64_t ptr = QueryMessage::get_size();
+
+  COPY_BUF(buf, txn_type, ptr);
+  COPY_BUF(buf, trans_id, ptr);
+  COPY_BUF(buf, item_id, ptr);
+  COPY_BUF(buf, seq_id, ptr);
+  COPY_BUF(buf, write_version, ptr);
+  COPY_BUF(buf, state, ptr);
+  COPY_BUF(buf, next_state, ptr);
+  COPY_BUF(buf, last_state, ptr);
+
+}
+void DAQueryMessage::copy_from_txn(TxnMgr* txn) {
+  QueryMessage::mcopy_from_txn(txn);
+  DAQuery* da_query = (DAQuery*)(txn->query);
+
+  txn_type = da_query->txn_type;
+  trans_id = da_query->trans_id;
+  item_id = da_query->item_id;
+  seq_id = da_query->seq_id;
+  write_version = da_query->write_version;
+  state = da_query->state;
+  next_state = da_query->next_state;
+  last_state = da_query->last_state;
+}
+
+void DAQueryMessage::copy_from_buf(char* buf) {
+  QueryMessage::copy_from_buf(buf);
+  uint64_t ptr = QueryMessage::get_size();
+
+  COPY_VAL(txn_type, buf, ptr);
+  // common txn input for both payment & new-order
+  COPY_VAL(trans_id, buf, ptr);
+  COPY_VAL(item_id, buf, ptr);
+  COPY_VAL(seq_id, buf, ptr);
+  COPY_VAL(write_version, buf, ptr);
+  // payment
+  COPY_VAL(state, buf, ptr);
+  COPY_VAL(next_state, buf, ptr);
+  COPY_VAL(last_state, buf, ptr);
+  assert(ptr == get_size());
+}
+
+void DAQueryMessage::copy_to_txn(TxnMgr* txn) {
+  QueryMessage::copy_to_txn(txn);
+  DAQuery* da_query = (DAQuery*)(txn->query);
+
+
+  txn->client_id = return_node_id;
+  da_query->txn_type = (DATxnType)txn_type;
+  da_query->trans_id = trans_id;
+  da_query->item_id = item_id;
+  da_query->seq_id = seq_id;
+  da_query->write_version = write_version;
+  da_query->state = state;
+  da_query->next_state = next_state;
+  da_query->last_state = last_state;
+
+}
+
+uint64_t DAQueryMessage::get_size() {
+  uint64_t size = QueryMessage::get_size();
+  size += sizeof(DATxnType);
+  size += sizeof(uint64_t) * 7;
+  return size;
+}
+void DAQueryMessage::release() { QueryMessage::release(); }
diff --git a/transport/message.h b/transport/message.h
index c7ae3c0..f265550 100644
--- a/transport/message.h
+++ b/transport/message.h
@@ -323,6 +323,27 @@ public:
 
 };
 
+class DAClientQueryMessage : public ClientQryMsg {
+ public:
+  void copy_from_buf(char* buf);//ok
+  void copy_to_buf(char* buf);//ok
+  void copy_from_query(BaseQry* query);//ok
+  void copy_from_txn(TxnMgr* txn);//ok
+  void copy_to_txn(TxnMgr* txn);
+  uint64_t get_size();
+  void init();
+  void release();
+
+  DATxnType txn_type;
+	uint64_t trans_id;
+	uint64_t item_id;
+	uint64_t seq_id;
+	uint64_t write_version;
+	uint64_t state;
+	uint64_t next_state;
+	uint64_t last_state;
+};
+
 class QueryMessage : public Msg {
 public:
   void copy_from_buf(char * buf);
@@ -413,5 +434,24 @@ public:
   Array<uint64_t> part_keys;
 };
 
+class DAQueryMessage : public QueryMessage {
+ public:
+  void copy_from_buf(char* buf);
+  void copy_to_buf(char* buf);
+  void copy_from_txn(TxnMgr* txn);
+  void copy_to_txn(TxnMgr* txn);
+  uint64_t get_size();
+  void init();
+  void release();
+
+  DATxnType txn_type;
+	uint64_t trans_id;
+	uint64_t item_id;
+	uint64_t seq_id;
+	uint64_t write_version;
+	uint64_t state;
+	uint64_t next_state;
+	uint64_t last_state;
+};
 
 #endif
diff --git a/transport/msg_thread.cpp b/transport/msg_thread.cpp
index 8e8a0c8..08e7e39 100644
--- a/transport/msg_thread.cpp
+++ b/transport/msg_thread.cpp
@@ -58,6 +58,25 @@ void MsgThread::send_batch(uint64_t dest_node_id) {
   INC_STATS(_thd_id,mtx[12],acquire_ts() - begintime);
 }
 
+char type2char1(DATxnType txn_type)
+{
+  switch (txn_type)
+  {
+    case DA_READ:
+      return 'R';
+    case DA_WRITE:
+      return 'W';
+    case DA_COMMIT:
+      return 'C';
+    case DA_ABORT:
+      return 'A';
+    case DA_SCAN:
+      return 'S';
+    default:
+      return 'U';
+  }
+}
+
 void MsgThread::run() {
   
   uint64_t begintime = acquire_ts();
@@ -82,7 +101,19 @@ void MsgThread::run() {
     assert(sbuf->cnt > 0);
     send_batch(dest_node_id);
   }
-
+  #if WORKLOAD == DA
+  if(!is_server&&true)
+  printf("cl seq_id:%lu type:%c trans_id:%lu item:%c state:%lu next_state:%lu write_version:%lu\n",
+      ((DAClientQueryMessage*)message)->seq_id,
+      type2char1(((DAClientQueryMessage*)message)->txn_type),
+      ((DAClientQueryMessage*)message)->trans_id,
+      static_cast<char>('x'+((DAClientQueryMessage*)message)->item_id),
+      ((DAClientQueryMessage*)message)->state,
+      (((DAClientQueryMessage*)message)->next_state),
+      ((DAClientQueryMessage*)message)->write_version);
+      fflush(stdout);
+  #endif
+  
   uint64_t copy_starttime = acquire_ts();
   message->copy_to_buf(&(sbuf->buffer[sbuf->ptr]));
   INC_STATS(_thd_id,msg_copy_output_time,acquire_ts() - copy_starttime);
